{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tmdybinding","title":"TMDybinding","text":"<p>TMDybinding is an open-source Python module for pybinding. This package contains the basic lattices in the pybinding <code>pb.Lattice()</code> format to create tight-binding models for TMDs.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation is simple, just run <pre><code>pip install tmdybinding\n</code></pre> The installation only contains the source files in the PyPi repository. This code does not need any compilation, this source can be used immediately in combination with pybinding.</p> <p>Installing pybinding</p> <p>Additionally, you might want to install the latest development version of pybinding. This latest version has additional tools to inspect the sublattices or orbitals, and analyze the wavefunction: <pre><code>pip install -i https://test.pypi.org/simple/ pybinding\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#making-a-lattice","title":"Making a lattice","text":"<p>To use TMDybinding, first follow the tutorial at pybinding.</p> <p>In TMDybinding, a <code>pb.Lattice()</code> is created for a specific TMD lattice. You need to make specific choices for the lattice you want to obtain:</p> <ul> <li>params the parameters to use with the model</li> <li>soc select if you want to include the spin orbit coupling (SOC)</li> <li>material select the material you want to use (depends on the parameters of choice)</li> <li>lat4 make a square unit cell (doubled to obtain the armchair direction)</li> </ul> <p>For example, you can take the parameters from G-B. Liu for <code>\"MoS2\"</code> in a hexagonal lattice without SOC, for the specific model used in their publication for the sixth-nearest neighbour hopping (in their paper this is described as the third-nearest neighbour hopping, as they only consider the metal <code>d</code>-orbitals): <pre><code>import tmdybinding as tmdy\n\n# make the lattice object\nlat = tmdy.TmdNN256Me(params=tmdy.liu6[\"MoS2\"]).lattice()\n\n# make a figure with the lattice\nlat.plot()\n</code></pre></p> The lattice structure for the TMD. <p>Selecting parameters and classes</p> <p>Please use the combinations of class and parameters as given in Documentation/Possible parameters.</p>"},{"location":"#using-the-lattice","title":"Using the lattice","text":"<p>Below is a small example of how to use the code for the 5-band model from Liu/Wu: <pre><code>import pybinding as pb\nimport tmdybinding as tmdy\n\n# get the parameters\nlat = tmdy.TmdNN256Meo(params=tmdy.wu[\"MoS2\"]).lattice()\nmodel = pb.Model(lat, pb.translational_symmetry())\nbz = lat.brillouin_zone()\nbands = pb.solver.lapack(model).calc_bands(\n    bz[3] * 0, bz[3], (bz[3] + bz[4]) / 2, bz[3] * 0\n)\nbands.plot(point_labels=[r\"$\\Gamma$\", \"$K$\", \"$M$\", r\"$\\Gamma$\"])\n</code></pre></p> The band structure for the TMD. <p>Further documentation is coming soon. Made by Bert Jorissen.</p>"},{"location":"#citing","title":"Citing","text":"<p>If you used this code in your research, please cite the following article: B. Jorissen, L. Covaci, B. Partoens, SciPost Phys. Core 7, 004 (2024).</p>"},{"location":"about/","title":"README.md","text":"<p>TMDybinding is an open-source Python module for Pybinding.</p>"},{"location":"about/#capabilities","title":"Capabilities","text":"<ul> <li>generate accurate lattices for most used TB models for TMDs</li> <li>easily add hopping</li> <li>automatic generation of lattice cell with 90-degree corners</li> <li>automatic inclusion of SOC terms</li> <li>automatic generation of hopping terms taking into account the symmetry of the orbital</li> <li>label all the different orbital contributions</li> <li>fully compatible with pybinding and KITE</li> </ul>"},{"location":"about/#installation","title":"Installation","text":"<p>That's easy, just run <pre><code>pip install tmdybinding\n</code></pre></p>"},{"location":"about/LICENSE/","title":"LICENSE.md","text":"<p>Attribution 4.0 International</p> <p>=======================================================================</p> <p>Creative Commons Corporation (\"Creative Commons\") is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \"as-is\" basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.</p> <p>Using Creative Commons Public Licenses</p> <p>Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.</p> <pre><code> Considerations for licensors: Our public licenses are\n intended for use by those authorized to give the public\n permission to use material in ways otherwise restricted by\n copyright and certain other rights. Our licenses are\n irrevocable. Licensors should read and understand the terms\n and conditions of the license they choose before applying it.\n Licensors should also secure all rights necessary before\n applying our licenses so that the public can reuse the\n material as expected. Licensors should clearly mark any\n material not subject to the license. This includes other CC-\n licensed material, or material used under an exception or\n limitation to copyright. More considerations for licensors:\nwiki.creativecommons.org/Considerations_for_licensors\n\n Considerations for the public: By using one of our public\n licenses, a licensor grants the public permission to use the\n licensed material under specified terms and conditions. If\n the licensor's permission is not necessary for any reason--for\n example, because of any applicable exception or limitation to\n copyright--then that use is not regulated by the license. Our\n licenses grant only permissions under copyright and certain\n other rights that a licensor has authority to grant. Use of\n the licensed material may still be restricted for other\n reasons, including because others have copyright or other\n rights in the material. A licensor may make special requests,\n such as asking that all changes be marked or described.\n Although not required by our licenses, you are encouraged to\n respect those requests where reasonable. More considerations\n for the public:\nwiki.creativecommons.org/Considerations_for_licensees\n</code></pre> <p>=======================================================================</p> <p>Creative Commons Attribution 4.0 International Public License</p> <p>By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.</p> <p>Section 1 -- Definitions.</p> <p>a. Adapted Material means material subject to Copyright and Similar      Rights that is derived from or based upon the Licensed Material      and in which the Licensed Material is translated, altered,      arranged, transformed, or otherwise modified in a manner requiring      permission under the Copyright and Similar Rights held by the      Licensor. For purposes of this Public License, where the Licensed      Material is a musical work, performance, or sound recording,      Adapted Material is always produced where the Licensed Material is      synched in timed relation with a moving image.</p> <p>b. Adapter's License means the license You apply to Your Copyright      and Similar Rights in Your contributions to Adapted Material in      accordance with the terms and conditions of this Public License.</p> <p>c. Copyright and Similar Rights means copyright and/or similar rights      closely related to copyright including, without limitation,      performance, broadcast, sound recording, and Sui Generis Database      Rights, without regard to how the rights are labeled or      categorized. For purposes of this Public License, the rights      specified in Section 2(b)(1)-(2) are not Copyright and Similar      Rights.</p> <p>d. Effective Technological Measures means those measures that, in the      absence of proper authority, may not be circumvented under laws      fulfilling obligations under Article 11 of the WIPO Copyright      Treaty adopted on December 20, 1996, and/or similar international      agreements.</p> <p>e. Exceptions and Limitations means fair use, fair dealing, and/or      any other exception or limitation to Copyright and Similar Rights      that applies to Your use of the Licensed Material.</p> <p>f. Licensed Material means the artistic or literary work, database,      or other material to which the Licensor applied this Public      License.</p> <p>g. Licensed Rights means the rights granted to You subject to the      terms and conditions of this Public License, which are limited to      all Copyright and Similar Rights that apply to Your use of the      Licensed Material and that the Licensor has authority to license.</p> <p>h. Licensor means the individual(s) or entity(ies) granting rights      under this Public License.</p> <p>i. Share means to provide material to the public by any means or      process that requires permission under the Licensed Rights, such      as reproduction, public display, public performance, distribution,      dissemination, communication, or importation, and to make material      available to the public including in ways that members of the      public may access the material from a place and at a time      individually chosen by them.</p> <p>j. Sui Generis Database Rights means rights other than copyright      resulting from Directive 96/9/EC of the European Parliament and of      the Council of 11 March 1996 on the legal protection of databases,      as amended and/or succeeded, as well as other essentially      equivalent rights anywhere in the world.</p> <p>k. You means the individual or entity exercising the Licensed Rights      under this Public License. Your has a corresponding meaning.</p> <p>Section 2 -- Scope.</p> <p>a. License grant.</p> <pre><code>   1. Subject to the terms and conditions of this Public License,\n      the Licensor hereby grants You a worldwide, royalty-free,\n      non-sublicensable, non-exclusive, irrevocable license to\n      exercise the Licensed Rights in the Licensed Material to:\n\n        a. reproduce and Share the Licensed Material, in whole or\n           in part; and\n\n        b. produce, reproduce, and Share Adapted Material.\n\n   2. Exceptions and Limitations. For the avoidance of doubt, where\n      Exceptions and Limitations apply to Your use, this Public\n      License does not apply, and You do not need to comply with\n      its terms and conditions.\n\n   3. Term. The term of this Public License is specified in Section\n      6(a).\n\n   4. Media and formats; technical modifications allowed. The\n      Licensor authorizes You to exercise the Licensed Rights in\n      all media and formats whether now known or hereafter created,\n      and to make technical modifications necessary to do so. The\n      Licensor waives and/or agrees not to assert any right or\n      authority to forbid You from making technical modifications\n      necessary to exercise the Licensed Rights, including\n      technical modifications necessary to circumvent Effective\n      Technological Measures. For purposes of this Public License,\n      simply making modifications authorized by this Section 2(a)\n      (4) never produces Adapted Material.\n\n   5. Downstream recipients.\n\n        a. Offer from the Licensor -- Licensed Material. Every\n           recipient of the Licensed Material automatically\n           receives an offer from the Licensor to exercise the\n           Licensed Rights under the terms and conditions of this\n           Public License.\n\n        b. No downstream restrictions. You may not offer or impose\n           any additional or different terms or conditions on, or\n           apply any Effective Technological Measures to, the\n           Licensed Material if doing so restricts exercise of the\n           Licensed Rights by any recipient of the Licensed\n           Material.\n\n   6. No endorsement. Nothing in this Public License constitutes or\n      may be construed as permission to assert or imply that You\n      are, or that Your use of the Licensed Material is, connected\n      with, or sponsored, endorsed, or granted official status by,\n      the Licensor or others designated to receive attribution as\n      provided in Section 3(a)(1)(A)(i).\n</code></pre> <p>b. Other rights.</p> <pre><code>   1. Moral rights, such as the right of integrity, are not\n      licensed under this Public License, nor are publicity,\n      privacy, and/or other similar personality rights; however, to\n      the extent possible, the Licensor waives and/or agrees not to\n      assert any such rights held by the Licensor to the limited\n      extent necessary to allow You to exercise the Licensed\n      Rights, but not otherwise.\n\n   2. Patent and trademark rights are not licensed under this\n      Public License.\n\n   3. To the extent possible, the Licensor waives any right to\n      collect royalties from You for the exercise of the Licensed\n      Rights, whether directly or through a collecting society\n      under any voluntary or waivable statutory or compulsory\n      licensing scheme. In all other cases the Licensor expressly\n      reserves any right to collect such royalties.\n</code></pre> <p>Section 3 -- License Conditions.</p> <p>Your exercise of the Licensed Rights is expressly made subject to the following conditions.</p> <p>a. Attribution.</p> <pre><code>   1. If You Share the Licensed Material (including in modified\n      form), You must:\n\n        a. retain the following if it is supplied by the Licensor\n           with the Licensed Material:\n\n             i. identification of the creator(s) of the Licensed\n                Material and any others designated to receive\n                attribution, in any reasonable manner requested by\n                the Licensor (including by pseudonym if\n                designated);\n\n            ii. a copyright notice;\n\n           iii. a notice that refers to this Public License;\n\n            iv. a notice that refers to the disclaimer of\n                warranties;\n\n             v. a URI or hyperlink to the Licensed Material to the\n                extent reasonably practicable;\n\n        b. indicate if You modified the Licensed Material and\n           retain an indication of any previous modifications; and\n\n        c. indicate the Licensed Material is licensed under this\n           Public License, and include the text of, or the URI or\n           hyperlink to, this Public License.\n\n   2. You may satisfy the conditions in Section 3(a)(1) in any\n      reasonable manner based on the medium, means, and context in\n      which You Share the Licensed Material. For example, it may be\n      reasonable to satisfy the conditions by providing a URI or\n      hyperlink to a resource that includes the required\n      information.\n\n   3. If requested by the Licensor, You must remove any of the\n      information required by Section 3(a)(1)(A) to the extent\n      reasonably practicable.\n\n   4. If You Share Adapted Material You produce, the Adapter's\n      License You apply must not prevent recipients of the Adapted\n      Material from complying with this Public License.\n</code></pre> <p>Section 4 -- Sui Generis Database Rights.</p> <p>Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:</p> <p>a. for the avoidance of doubt, Section 2(a)(1) grants You the right      to extract, reuse, reproduce, and Share all or a substantial      portion of the contents of the database;</p> <p>b. if You include all or a substantial portion of the database      contents in a database in which You have Sui Generis Database      Rights, then the database in which You have Sui Generis Database      Rights (but not its individual contents) is Adapted Material; and</p> <p>c. You must comply with the conditions in Section 3(a) if You Share      all or a substantial portion of the contents of the database.</p> <p>For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.</p> <p>Section 5 -- Disclaimer of Warranties and Limitation of Liability.</p> <p>a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE      EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS      AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF      ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,      IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,      WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR      PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,      ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT      KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT      ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.</p> <p>b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE      TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,      NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,      INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,      COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR      USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN      ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR      DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR      IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.</p> <p>c. The disclaimer of warranties and limitation of liability provided      above shall be interpreted in a manner that, to the extent      possible, most closely approximates an absolute disclaimer and      waiver of all liability.</p> <p>Section 6 -- Term and Termination.</p> <p>a. This Public License applies for the term of the Copyright and      Similar Rights licensed here. However, if You fail to comply with      this Public License, then Your rights under this Public License      terminate automatically.</p> <p>b. Where Your right to use the Licensed Material has terminated under      Section 6(a), it reinstates:</p> <pre><code>   1. automatically as of the date the violation is cured, provided\n      it is cured within 30 days of Your discovery of the\n      violation; or\n\n   2. upon express reinstatement by the Licensor.\n\n For the avoidance of doubt, this Section 6(b) does not affect any\n right the Licensor may have to seek remedies for Your violations\n of this Public License.\n</code></pre> <p>c. For the avoidance of doubt, the Licensor may also offer the      Licensed Material under separate terms or conditions or stop      distributing the Licensed Material at any time; however, doing so      will not terminate this Public License.</p> <p>d. Sections 1, 5, 6, 7, and 8 survive termination of this Public      License.</p> <p>Section 7 -- Other Terms and Conditions.</p> <p>a. The Licensor shall not be bound by any additional or different      terms or conditions communicated by You unless expressly agreed.</p> <p>b. Any arrangements, understandings, or agreements regarding the      Licensed Material not stated herein are separate from and      independent of the terms and conditions of this Public License.</p> <p>Section 8 -- Interpretation.</p> <p>a. For the avoidance of doubt, this Public License does not, and      shall not be interpreted to, reduce, limit, restrict, or impose      conditions on any use of the Licensed Material that could lawfully      be made without permission under this Public License.</p> <p>b. To the extent possible, if any provision of this Public License is      deemed unenforceable, it shall be automatically reformed to the      minimum extent necessary to make it enforceable. If the provision      cannot be reformed, it shall be severed from this Public License      without affecting the enforceability of the remaining terms and      conditions.</p> <p>c. No term or condition of this Public License will be waived and no      failure to comply consented to unless expressly agreed to by the      Licensor.</p> <p>d. Nothing in this Public License constitutes or may be interpreted      as a limitation upon, or waiver of, any privileges and immunities      that apply to the Licensor or You, including from the legal      processes of any jurisdiction or authority.</p> <p>=======================================================================</p> <p>Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark \"Creative Commons\" or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.</p> <p>Creative Commons may be contacted at creativecommons.org.</p>"},{"location":"about/changelog/","title":"changelog.md","text":""},{"location":"about/changelog/#changelog","title":"Changelog","text":""},{"location":"about/changelog/#2024-06-19-010-change-of-rotation-matrices-documentation","title":"2024-06-19 - 0.1.0: Change of rotation matrices &amp; documentation","text":"<p>Added a bugfix for the right rotation matrices, correction for the different symmetry is made in the parameters.</p>"},{"location":"about/changelog/#2024-03-18-002-added-more-parameters","title":"2024-03-18 - 0.0.2: Added more parameters","text":"<p>The parameters are structured in dicts for easy access.</p>"},{"location":"about/changelog/#2023-09-13-001-first-release-of-tmdybinding","title":"2023-09-13 - 0.0.1: First release of TMDybinding","text":"<p>First release, added to PyPi</p>"},{"location":"documentation/","title":"Documentation","text":"<p>Here you can find the API and a small explenation about the parameters used in the package.</p>"},{"location":"documentation/api/","title":"API","text":"<p>The TMDybinidng package consists of several base lattices, objects to store the parameters for these lattices, functions to build the matrices associated to the hoppings of that model and classes that help user in defining new lattices with (rotational) symmetric aspects for orbitals of non-zero ml-quantum number.</p>"},{"location":"documentation/api/#base-lattices","title":"Base lattices","text":"<p>Tight-binding lattices for TMDs for the Pybinding-package.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice","title":"<code>AbstractLattice</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for a tmd-lattice</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>class AbstractLattice(ABC):\n    \"\"\"Abstract class for a tmd-lattice\"\"\"\n\n    def __init__(self, orbital: LatticeOrbitals, params: ParametersList, soc: bool = False,\n                 soc_eo_flip: bool = False, lat4: bool = False, single_orbital: bool = False, soc_sz_part: bool = True,\n                 soc_polarized: bool = False, soc_sz: float = 1.,\n                 n_v: int = 0, n_b: int = 0, lattice_name: str = \"Abstract Lattice\"):\n        \"\"\"Make an AbstractLattice object with the given parameters.\n\n        Parameters:\n            orbital (LatticeOrbitals): The orbitals for the lattice model.\n            params (ParametersList): The parameters for the lattice model.\n            soc (bool): If True, the spin-orbit coupling is considere.\n            soc_eo_flip (bool): If True, the spin-flip term is included.\n            lat4 (bool): If True, the lattice is a 4-atom lattice for use with the armchair direction.\n            single_orbital (bool): If True, the lattice is a combination of suborbitals (slower as no matrices are used)\n            soc_sz_part (bool): If False, the hamiltonian will not include the Sz part of the spin-orbit coupling.\n            soc_polarized (bool): If True, the spin-orbit coupling is polarized (only spin-up part, given by `soc_sz`).\n            soc_sz (float): The Sz part of the spin-orbit coupling.\n            n_v (int): The index of the highest valence band (in the unitcell).\n            n_b (int): The number of bands (in the unitcell).\n            lattice_name (str): The name of the lattice. The name of the matrial is obtained from `params`.\n        \"\"\"\n        self.lattice_params = VariableStorage()\n        self.orbital: LatticeOrbitals = orbital\n        self.__n_valence_band: int = n_v\n        self.__n_bands: int = n_b\n        self.__name: str = \"MoS2\"\n        self.__x_name: str = \"S\"\n        self.__x_type: str = \"X\"\n        self.__m_name: str = \"Mo\"\n        self.__m_type: str = \"M\"\n        self.__params: ParametersList = ParametersList()\n        self.__soc_eo_flip: bool = False\n        self.__lattice_name: str = lattice_name\n        self._lat4: bool = lat4\n        self.single_orbital: bool = single_orbital\n        self.soc: bool = soc\n        self.soc_polarized: bool = soc_polarized\n        self.soc_sz_part: bool = soc_sz_part\n        self.sz: float = soc_sz\n        self.params = params\n        self.soc_eo_flip = soc_eo_flip\n\n    @property\n    def soc_eo_flip(self) -&gt; bool:\n        \"\"\"If True, the spin-flip term is included.\n        The structure is checked for the right shape and properties that it supports a spin-flip term.\n        \"\"\"\n        return self.__soc_eo_flip\n\n    @soc_eo_flip.setter\n    def soc_eo_flip(self, pol_bool: bool):\n        if pol_bool:\n            if self.lattice_params.h_0_m is not None:\n                assert len(self.orbital.l_number[self.orb_type(self.m_name)]) == 5, \\\n                    \"the metal doesn't have the right shape for spin-flip term\"\n                assert sorted(self.orbital.l_number[self.orb_type(self.m_name)]) == sorted([0, 2, -2, 1, -1]), \\\n                    \"the metal l is wrong for spin-flip\"\n            if self.lattice_params.h_0_c is not None:\n                assert len(self.orbital.l_number[self.orb_type(self.x_name)]) == 6, \\\n                    \"the chal. doesn't have the right shape for spin-flip term\"\n                assert sorted(self.orbital.l_number[self.orb_type(self.x_name)]) == sorted([1, -1, 0, 1, -1, 0]), \\\n                    \"the chal. l is wrong for spin-flip\"\n        self.__soc_eo_flip = pol_bool\n\n    @property\n    def params(self) -&gt; ParametersList:\n        \"\"\"The parameters for the lattice model.\"\"\"\n        return self.__params\n\n    @params.setter\n    def params(self, params: ParametersList):\n        self.__params = params\n        self.name = self.params[\"material\"]\n\n    @property\n    def lattice_name(self) -&gt; str:\n        \"\"\"The name of the lattice. This is not the name of the material.\"\"\"\n        return self.__lattice_name\n\n    @lattice_name.setter\n    def lattice_name(self, lattice_name: str):\n        self.__lattice_name = lattice_name\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of the material.\"\"\"\n        return self.__name\n\n    @property\n    def m_name(self) -&gt; str:\n        \"\"\"The name of the metal atom.\"\"\"\n        return self.__m_name\n\n    def orb_type(self, z_name: str) -&gt; Optional[str]:\n        \"\"\"Return the orbital type of the atom with the given name. Usefull for the case when `lat4` is True.\n        Returns `\"M\"` for the metal atom and `\"X\"` for the chalcogen atom.\n        \"\"\"\n        if z_name == self.m_name or (self.lat4 and z_name == self.m_name + \"2\"):\n            return self.__m_type\n        elif z_name == self.x_name or (self.lat4 and z_name == self.x_name + \"2\"):\n            return self.__x_type\n        else:\n            return None\n\n    def z_name(self, orb_type: str) -&gt; Optional[str]:\n        \"\"\"Return the name of the atom with the given orbital type, for example, obtain `\"S\"` from `\"X\"` in the case\n        the material is `\"MoS2\"`.\n        \"\"\"\n        if orb_type == self.__m_type:\n            return self.m_name\n        elif orb_type == self.__x_type:\n            return self.x_name\n        else:\n            return None\n\n    @property\n    def x_name(self) -&gt; str:\n        \"\"\"The name of the chalcogen atom.\"\"\"\n        return self.__x_name\n\n    @name.setter\n    def name(self, name: str):\n        self.__name = name\n        self.__m_name, self.__x_name = re.findall(\"[A-Z][a-z]*\", self.name)\n        self._generate_matrices()\n\n    @property\n    def lat4(self) -&gt; bool:\n        \"\"\"If True, the lattice is a 4-atom lattice for use with the armchair direction.\"\"\"\n        return self._lat4\n\n    @lat4.setter\n    def lat4(self, lat4: bool):\n        self._lat4 = lat4\n        self._generate_matrices()\n\n    @property\n    def a1(self) -&gt; np.ndarray:\n        \"\"\"The first lattice vector. Corrected if `lat4` is True.\"\"\"\n        return np.array([1, 0]) * self.lattice_params.a\n\n    @property\n    def a2(self) -&gt; np.ndarray:\n        \"\"\"The second lattice vector. Corrected if `lat4` is True.\"\"\"\n        return (np.array([0, np.sqrt(3)]) if self.lat4 else np.array([-1 / 2, np.sqrt(3) / 2])) * self.lattice_params.a\n\n    @property\n    def soc_doubled_ham(self) -&gt; bool:\n        \"\"\"If True, the hamiltonian is doubled for the spin-orbit coupling.\"\"\"\n        return not self.soc_polarized if self.soc else False\n\n    @property\n    def soc_eo_flip_used(self) -&gt; bool:\n        \"\"\"If True, the spin-flip term is used.\"\"\"\n        return self.soc and self.soc_eo_flip and not self.soc_polarized\n\n    @property\n    def n_valence_band(self) -&gt; int:\n        \"\"\"The index of the highest valence band. Corrected for the SOC and `lat4`.\"\"\"\n        return (self.__n_valence_band + 1) * 2 - 1 if self.soc_doubled_ham else self.__n_valence_band\n\n    @property\n    def n_bands(self) -&gt; int:\n        \"\"\"The total number of bands. Corrected for the SOC and `lat4`.\"\"\"\n        return self.__n_bands * (2 if self.soc_doubled_ham else 1)\n\n    @property\n    def _m_orbs(self) -&gt; List[str]:\n        m_orbs = [self.m_name + mi for mi in self.orbital.orbs[self.orb_type(self.m_name)]]\n        if self.soc_doubled_ham:\n            m_orbs = [mi + \"u\" for mi in m_orbs] + [mi + \"d\" for mi in m_orbs]\n        return m_orbs\n\n    @property\n    def _m2_orbs(self) -&gt; List[str]:\n        m2_orbs = [self.m_name + \"2\" + mi for mi in self.orbital.orbs[self.orb_type(self.m_name)]]\n        if self.soc_doubled_ham:\n            m2_orbs = [mi + \"u\" for mi in m2_orbs] + [mi + \"d\" for mi in m2_orbs]\n        return m2_orbs\n\n    @property\n    def _c_orbs(self) -&gt; List[str]:\n        c_orbs = [self.x_name + ci for ci in self.orbital.orbs[self.orb_type(self.x_name)]]\n        if self.soc_doubled_ham:\n            c_orbs = [ci + \"u\" for ci in c_orbs] + [ci + \"d\" for ci in c_orbs]\n        return c_orbs\n\n    @property\n    def _c2_orbs(self) -&gt; List[str]:\n        c2_orbs = [self.x_name + \"2\" + ci for ci in self.orbital.orbs[self.orb_type(self.x_name)]]\n        if self.soc_doubled_ham:\n            c2_orbs = [ci + \"u\" for ci in c2_orbs] + [ci + \"d\" for ci in c2_orbs]\n        return c2_orbs\n\n    @staticmethod\n    def _make_name(h_name: str, n_i: int, nfi: str, ntj: str) -&gt; str:\n        return h_name + \"-\" + str(n_i) + \"-\" + nfi + \"-\" + ntj\n\n    @staticmethod\n    def _separate_name(h_name_i) -&gt; Tuple[str, int, str, str]:\n        out = re.findall(\"[^-]+(?:[^-]*)*\", h_name_i)\n        assert len(out) == 4, \"The given string isn't generated by the right function, the length isn't 4\"\n        out[1] = int(out[1])\n        return str(out[0]), int(out[1]), str(out[2]), str(out[3])\n\n    @abstractmethod\n    def _generate_matrices(self):\n        \"\"\"Generate the matrices for the lattice model.\n        This function should be implemented in the child class.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def _ham(h: np.ndarray, ur_l: np.ndarray, ur_r: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        return h, ur_l.dot(h.dot(ur_r.T)), ur_l.T.dot(h.dot(ur_r))\n\n    @staticmethod\n    def _reorder(matrix: np.ndarray, keys: Tuple[List[int], List[int]]) -&gt; np.ndarray:\n        return np.array([[matrix[xi, yi] for yi in keys[1]] for xi in keys[0]])\n\n    def block_diag(self, *matrices) -&gt; np.ndarray:\n        \"\"\"Make a block diagonal matrix from the given matrices.\"\"\"\n        if len(matrices) == 1:\n            return matrices[0]\n        else:\n            matrix0 = matrices[0]\n            matrix1 = self.block_diag(*matrices[1:])\n            shape_0 = np.shape(matrix0)\n            shape_1 = np.shape(matrix1)\n            z_1 = [shape_0[-2], shape_1[-1]]\n            z_2 = [shape_1[-2], shape_0[-1]]\n            nd = len(shape_0)\n            assert nd == len(shape_1), \"The matrices don't have the right sizes in the additional dimensions\"\n            if nd &gt; 2:\n                for sh in shape_1[:-2]:\n                    z_1.insert(0, sh)\n                    z_2.insert(0, sh)\n            return np.concatenate((np.concatenate((matrix0, np.zeros(z_1)), axis=nd - 1),\n                                   np.concatenate((np.zeros(z_2), matrix1), axis=nd - 1)), axis=nd - 2)\n\n    def _make_onsite(self, matrix, name, lamb):\n        def ham_sz(sz):\n            if self.soc_sz_part:\n                s_part = sz * lamb * 1j * self.orbital.s_h[self.orb_type(name)]\n                return matrix + s_part\n            else:\n                return np.array(matrix, dtype=complex)\n\n        if self.soc:\n            if self.soc_polarized:\n                return ham_sz(self.sz)\n            else:\n                return self.block_diag(ham_sz(self.sz), ham_sz(-self.sz))\n        else:\n            return ham_sz(0.)\n\n    def _make_h(self, matrix, from_name, to_name):\n        (h_1, h_2, h_3) = self._ham(matrix,\n                                    self.orbital.ur[self.orb_type(to_name)],\n                                    self.orbital.ur[self.orb_type(from_name)])\n        if self.soc_doubled_ham:\n            h_1 = np.kron(np.eye(2), h_1)\n            h_2 = np.kron(np.eye(2), h_2)\n            h_3 = np.kron(np.eye(2), h_3)\n        return h_1, h_2, h_3\n\n    def _make_h_angle(self, matrix, from_name, to_name, angle):\n        (h_1, h_2, h_3) = self._ham(matrix,\n                                    self.orbital.ur_angle(angle)[self.orb_type(to_name)],\n                                    self.orbital.ur_angle(angle)[self.orb_type(from_name)])\n        return h_1, h_2, h_3\n\n    def _add_hopping(self, lat, mat, f_n, t_n, cos, fnl, tnl, h_name):\n        hn = self._make_h(mat, f_n, t_n)\n        n_n_n = [0, 1, 2]\n        if self.lat4:\n            hn = [hn[int(ih / 2)] for ih in range(6)]\n            n_n_n = [0, 0, 1, 1, 2, 2]\n        # n_n = 6 if self.lat4 else 3\n        if self.single_orbital:\n            for f_i, nf_i in enumerate(fnl):\n                for t_j, nt_j in enumerate(tnl):\n                    h_names = [self._make_name(h_name, n_i, nfi, ntj) for n_i, nfi, ntj in zip(n_n_n, nf_i, nt_j)]\n                    lat.register_hopping_energies(dict([(h_n_i, h.conj().T[f_i, t_j]) for h_n_i, h in zip(h_names, hn)]))\n                    lat.add_hoppings(*[(co, nfi, ntj, h_n_i) for co, h_n_i, nfi, ntj in zip(cos, h_names, nf_i, nt_j)])\n        else:\n            h_names = [self._make_name(h_name, n_i, nfi, ntj) for n_i, nfi, ntj in zip(n_n_n, fnl, tnl)]\n            lat.register_hopping_energies(dict([(h_n_i, h.conj().T) for h_n_i, h in zip(h_names, hn)]))\n            lat.add_hoppings(*[(co, nfi, ntj, h_n_i) for co, h_n_i, nfi, ntj in zip(cos, h_names, fnl, tnl)])\n        return lat\n\n    def lattice(self) -&gt; pb.Lattice:\n        \"\"\"Make the lattice model. It returns a `pybinding.Lattice` object.\"\"\"\n        lat = pb.Lattice(a1=self.a1, a2=self.a2)\n        m_orbs, m2_orbs = 0, 0\n        c_orbs, c2_orbs = 0, 0\n        if self.lattice_params.h_0_m is not None:\n            m_orbs = self._m_orbs\n            m2_orbs = self._m2_orbs\n            h_0_m = self._make_onsite(self.lattice_params.h_0_m, self.m_name, self.lattice_params.lamb_m)\n            n_m, n_c = 0, 0\n            if self.soc_eo_flip_used:\n                soc_part_m = np.zeros((5, 5)) * 1j\n                soc_part_m[3:, :3] = self.sz * self.lattice_params.lamb_m * np.array(\n                    [[np.sqrt(3) / 2, -1 / 2, 1j / 2],\n                     [-1j / 2 * np.sqrt(3), -1j / 2, -1 / 2]])\n                soc_part_m[:3, 3:] = -soc_part_m[3:, :3].T\n                reorder_keys = [np.abs(np.array([0, 2, -2, 1, -1]) - key).argmin()\n                                for key in self.orbital.l_number[self.orb_type(self.m_name)]]\n                soc_part_m = self._reorder(soc_part_m, (reorder_keys, reorder_keys))\n                h_0_m[:5, 5:] = soc_part_m\n                h_0_m[5:, :5] = soc_part_m.conj().T\n\n            if self.single_orbital:\n                n_m = len(m_orbs)\n                for i_m in range(n_m):\n                    lat.add_one_sublattice(m_orbs[i_m], [0, 0], np.real(h_0_m[i_m, i_m]))\n                for i_m in range(n_m):\n                    for j_m in np.arange(i_m + 1, n_m):\n                        h_name = self._make_name(\"h_0_m\", 0, m_orbs[i_m], m_orbs[j_m])\n                        lat.register_hopping_energies(dict([(h_name, h_0_m[i_m, j_m])]))\n                        lat.add_one_hopping([0, 0], m_orbs[i_m], m_orbs[j_m], h_name)\n            else:\n                lat.add_one_sublattice(self.m_name, [0, 0], h_0_m)\n            if self.lat4:\n                if self.single_orbital:\n                    for i_m in range(n_m):\n                        lat.add_one_sublattice(m2_orbs[i_m], [0, 0], np.real(h_0_m[i_m, i_m]))\n                    for i_m in range(n_m):\n                        for j_m in np.arange(i_m + 1, n_m):\n                            h_name = self._make_name(\"h_0_m\", 0, m2_orbs[i_m], m2_orbs[j_m])\n                            lat.register_hopping_energies(dict([(h_name, h_0_m[i_m, j_m])]))\n                            lat.add_one_hopping([0, 0], m2_orbs[i_m], m2_orbs[j_m], h_name)\n                else:\n                    lat.add_one_sublattice(self.m_name + \"2\",\n                                           [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 2],\n                                           h_0_m)\n\n        if self.lattice_params.h_0_c is not None:\n            h_0_c = self._make_onsite(self.lattice_params.h_0_c, self.x_name, self.lattice_params.lamb_c)\n            c_orbs = self._c_orbs\n            c2_orbs = self._c2_orbs\n            n_c = len(c_orbs)\n            if self.soc_eo_flip_used:\n                soc_part_c = np.zeros((6, 6)) * 1j\n                soc_part_c[:3, 3:] = self.sz * self.lattice_params.lamb_c * np.array(\n                    [[0, 0, 1 / 2],\n                     [0, 0, -1j / 2],\n                     [-1 / 2, 1j / 2, 0]])\n                soc_part_c[3:, :3] = -soc_part_c[:3, 3:].T\n                reorder_keys1 = [np.abs(np.array([1, -1, 0]) - key).argmin()\n                                 for key in self.orbital.l_number[self.orb_type(self.x_name)][:3]]\n                reorder_keys2 = [3 + np.abs(np.array([1, -1, 0]) - key).argmin()\n                                 for key in self.orbital.l_number[self.orb_type(self.x_name)][3:]]\n                soc_part_c = self._reorder(soc_part_c, (reorder_keys1 + reorder_keys2, reorder_keys1 + reorder_keys2))\n                h_0_c[:6, 6:] = soc_part_c\n                h_0_c[6:, :6] = soc_part_c.conj().T\n            if self.single_orbital:\n                for i_c in range(n_c):\n                    lat.add_one_sublattice(c_orbs[i_c],\n                                           [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 6],\n                                           np.real(h_0_c[i_c, i_c]))\n                for i_c in range(n_c):\n                    for j_c in np.arange(i_c + 1, n_c):\n                        h_name = self._make_name(\"h_0_c\", 0, c_orbs[i_c], c_orbs[j_c])\n                        lat.register_hopping_energies(dict([(h_name, h_0_c[i_c, j_c])]))\n                        lat.add_one_hopping([0, 0], c_orbs[i_c], c_orbs[j_c], h_name)\n            else:\n                lat.add_one_sublattice(self.x_name,\n                                       [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 6],\n                                       h_0_c)\n\n            if self.lat4:\n                if self.single_orbital:\n                    for i_c in range(n_c):\n                        lat.add_one_sublattice(c2_orbs[i_c],\n                                               [0, self.lattice_params.a * 2 * np.sqrt(3) / 6],\n                                               np.real(h_0_c[i_c, i_c]))\n                    for i_c in range(n_c):\n                        for j_c in np.arange(i_c + 1, n_c):\n                            h_name = self._make_name(\"h_0_c\", 0, c2_orbs[i_c], c2_orbs[j_c])\n                            lat.register_hopping_energies(dict([(h_name, h_0_c[i_c, j_c])]))\n                            lat.add_one_hopping([0, 0], c2_orbs[i_c], c2_orbs[j_c], h_name)\n                else:\n                    lat.add_one_sublattice(self.x_name + \"2\",\n                                           [0, self.lattice_params.a * 2 * np.sqrt(3) / 3],\n                                           h_0_c)\n\n        if self.lattice_params.h_1_m is not None:\n            cos = [[-1, -1], [0, 0], [-1, 0]] if not self.lat4 else [[0, -1], [0, 0], [0, 0], [1, 0], [-1, 0], [0, 0]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c2, c1, c1, c2, c1, c2] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name + \"2\", self.x_name, self.x_name, self.x_name + \"2\", self.x_name, self.x_name + \"2\"]\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_1_m,\n                                    f_n=self.m_name,\n                                    t_n=self.x_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_1_m\")\n\n        if self.lattice_params.h_2_m is not None:\n            cos = [[1, 0], [0, 1], [-1, -1]] if not self.lat4 else [[1, 0], [1, 0], [-1, 0], [0, 1], [-1, -1], [0, 0]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [[m1, m2, m2, m1, m2, m1] for (m1, m2) in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\", self.m_name + \"2\", self.m_name, self.m_name + \"2\", self.m_name]\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_2_m,\n                                    f_n=self.m_name,\n                                    t_n=self.m_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_2_m\")\n\n        if self.lattice_params.h_2_c is not None:\n            cos = [[1, 0], [0, 1], [-1, -1]] if not self.lat4 else [[1, 0], [1, 0], [0, 0], [-1, 1], [0, -1], [-1, 0]]\n            fnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name]\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_2_c,\n                                    f_n=self.x_name,\n                                    t_n=self.x_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_2_c\")\n\n        if self.lattice_params.h_3_m is not None:\n            cos = [[0, 1], [-2, -1], [0, -1]] if not self.lat4 else [[0, 0], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [ci * 3 for ci in zip(c2_orbs, c_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name + \"2\", self.x_name] * 3\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_3_m,\n                                    f_n=self.m_name,\n                                    t_n=self.x_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_3_m\")\n\n        if self.lattice_params.h_4_m is not None:\n            _, h_4_ma, h_4_mb = self._make_h_angle(\n                self.lattice_params.h_4_m, self.m_name, self.x_name, np.arctan(np.sqrt(3) / 5)\n            )\n            cosa = [[-1, -2], [1, 1], [-2, 0]] \\\n                if not self.lat4 else [[0, -1], [1, -1], [1, 0], [1, 1], [-2, 0], [-1, 0]]\n            cosb = [[-2, -2], [1, 0], [-1, 1]] \\\n                if not self.lat4 else [[-1, -1], [0, -1], [1, 0], [2, 0], [-1, 0], [-1, 1]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnla = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c1, c2, c2, c1, c1, c2] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name, self.x_name + \"2\"] * 3\n                )\n            )\n            tnlb = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c1, c2, c1, c2, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name] * 3\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=h_4_ma,\n                                    f_n=self.m_name,\n                                    t_n=self.x_name,\n                                    cos=cosa,\n                                    fnl=fnl,\n                                    tnl=tnla,\n                                    h_name=\"h_4_ma\")\n            lat = self._add_hopping(lat=lat,\n                                    mat=h_4_mb,\n                                    f_n=self.m_name,\n                                    t_n=self.x_name,\n                                    cos=cosb,\n                                    fnl=fnl,\n                                    tnl=tnlb,\n                                    h_name=\"h_4_mb\")\n\n        if self.lattice_params.h_5_m is not None:\n            cos = [[1, 2], [-2, -1], [1, -1]] if not self.lat4 else [[0, 1], [0, 1], [-2, -1], [-1, 0], [1, -1], [2, 0]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [[m1, m2, m2, m1, m2, m1] for (m1, m2) in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\", self.m_name + \"2\", self.m_name, self.m_name + \"2\", self.m_name]\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_5_m,\n                                    f_n=self.m_name,\n                                    t_n=self.m_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_5_m\")\n\n        if self.lattice_params.h_5_c is not None:\n            cos = [[1, 2], [-2, -1], [1, -1]] if not self.lat4 else [[0, 1], [0, 1], [-1, -1], [-2, 0], [2, -1], [1, 0]]\n            fnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name]\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_5_c,\n                                    f_n=self.x_name,\n                                    t_n=self.x_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_5_c\")\n\n        if self.lattice_params.h_6_m is not None:\n            cos = [[2, 0], [0, 2], [-2, -2]] \\\n                if not self.lat4 else [[2, 0], [2, 0], [-1, 1], [-1, 1], [-1, -1], [-1, -1]]\n            fnl = (\n                (\n                    [[m_i] * 3 for m_i in m_orbs]\n                    if not self.lat4 else\n                    [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n                ) if self.single_orbital else (\n                    [self.m_name] * 3\n                    if not self.lat4 else\n                    [self.m_name, self.m_name + \"2\"] * 3\n                )\n            )\n            tnl = fnl\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_6_m,\n                                    f_n=self.m_name,\n                                    t_n=self.m_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_6_m\")\n\n        if self.lattice_params.h_6_c is not None:\n            cos = [[2, 0], [0, 2], [-2, -2]] \\\n                if not self.lat4 else [[2, 0], [2, 0], [-1, 1], [-1, 1], [-1, -1], [-1, -1]]\n            fnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\"] * 3\n                )\n            )\n            tnl = (\n                (\n                    [[c_i] * 3 for c_i in c_orbs]\n                    if not self.lat4 else\n                    [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n                ) if self.single_orbital else (\n                    [self.x_name] * 3\n                    if not self.lat4 else\n                    [self.x_name, self.x_name + \"2\"] * 3\n                )\n            )\n            lat = self._add_hopping(lat=lat,\n                                    mat=self.lattice_params.h_6_c,\n                                    f_n=self.x_name,\n                                    t_n=self.x_name,\n                                    cos=cos,\n                                    fnl=fnl,\n                                    tnl=tnl,\n                                    h_name=\"h_6_c\")\n        return lat\n</code></pre>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.a1","title":"<code>a1: np.ndarray</code>  <code>property</code>","text":"<p>The first lattice vector. Corrected if <code>lat4</code> is True.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.a2","title":"<code>a2: np.ndarray</code>  <code>property</code>","text":"<p>The second lattice vector. Corrected if <code>lat4</code> is True.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.lat4","title":"<code>lat4: bool</code>  <code>property</code> <code>writable</code>","text":"<p>If True, the lattice is a 4-atom lattice for use with the armchair direction.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.lattice_name","title":"<code>lattice_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the lattice. This is not the name of the material.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.m_name","title":"<code>m_name: str</code>  <code>property</code>","text":"<p>The name of the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.n_bands","title":"<code>n_bands: int</code>  <code>property</code>","text":"<p>The total number of bands. Corrected for the SOC and <code>lat4</code>.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.n_valence_band","title":"<code>n_valence_band: int</code>  <code>property</code>","text":"<p>The index of the highest valence band. Corrected for the SOC and <code>lat4</code>.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the material.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.params","title":"<code>params: ParametersList</code>  <code>property</code> <code>writable</code>","text":"<p>The parameters for the lattice model.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.soc_doubled_ham","title":"<code>soc_doubled_ham: bool</code>  <code>property</code>","text":"<p>If True, the hamiltonian is doubled for the spin-orbit coupling.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.soc_eo_flip","title":"<code>soc_eo_flip: bool</code>  <code>property</code> <code>writable</code>","text":"<p>If True, the spin-flip term is included. The structure is checked for the right shape and properties that it supports a spin-flip term.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.soc_eo_flip_used","title":"<code>soc_eo_flip_used: bool</code>  <code>property</code>","text":"<p>If True, the spin-flip term is used.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.x_name","title":"<code>x_name: str</code>  <code>property</code>","text":"<p>The name of the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.__init__","title":"<code>__init__(orbital, params, soc=False, soc_eo_flip=False, lat4=False, single_orbital=False, soc_sz_part=True, soc_polarized=False, soc_sz=1.0, n_v=0, n_b=0, lattice_name='Abstract Lattice')</code>","text":"<p>Make an AbstractLattice object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>orbital</code> <code>LatticeOrbitals</code> <p>The orbitals for the lattice model.</p> required <code>params</code> <code>ParametersList</code> <p>The parameters for the lattice model.</p> required <code>soc</code> <code>bool</code> <p>If True, the spin-orbit coupling is considere.</p> <code>False</code> <code>soc_eo_flip</code> <code>bool</code> <p>If True, the spin-flip term is included.</p> <code>False</code> <code>lat4</code> <code>bool</code> <p>If True, the lattice is a 4-atom lattice for use with the armchair direction.</p> <code>False</code> <code>single_orbital</code> <code>bool</code> <p>If True, the lattice is a combination of suborbitals (slower as no matrices are used)</p> <code>False</code> <code>soc_sz_part</code> <code>bool</code> <p>If False, the hamiltonian will not include the Sz part of the spin-orbit coupling.</p> <code>True</code> <code>soc_polarized</code> <code>bool</code> <p>If True, the spin-orbit coupling is polarized (only spin-up part, given by <code>soc_sz</code>).</p> <code>False</code> <code>soc_sz</code> <code>float</code> <p>The Sz part of the spin-orbit coupling.</p> <code>1.0</code> <code>n_v</code> <code>int</code> <p>The index of the highest valence band (in the unitcell).</p> <code>0</code> <code>n_b</code> <code>int</code> <p>The number of bands (in the unitcell).</p> <code>0</code> <code>lattice_name</code> <code>str</code> <p>The name of the lattice. The name of the matrial is obtained from <code>params</code>.</p> <code>'Abstract Lattice'</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def __init__(self, orbital: LatticeOrbitals, params: ParametersList, soc: bool = False,\n             soc_eo_flip: bool = False, lat4: bool = False, single_orbital: bool = False, soc_sz_part: bool = True,\n             soc_polarized: bool = False, soc_sz: float = 1.,\n             n_v: int = 0, n_b: int = 0, lattice_name: str = \"Abstract Lattice\"):\n    \"\"\"Make an AbstractLattice object with the given parameters.\n\n    Parameters:\n        orbital (LatticeOrbitals): The orbitals for the lattice model.\n        params (ParametersList): The parameters for the lattice model.\n        soc (bool): If True, the spin-orbit coupling is considere.\n        soc_eo_flip (bool): If True, the spin-flip term is included.\n        lat4 (bool): If True, the lattice is a 4-atom lattice for use with the armchair direction.\n        single_orbital (bool): If True, the lattice is a combination of suborbitals (slower as no matrices are used)\n        soc_sz_part (bool): If False, the hamiltonian will not include the Sz part of the spin-orbit coupling.\n        soc_polarized (bool): If True, the spin-orbit coupling is polarized (only spin-up part, given by `soc_sz`).\n        soc_sz (float): The Sz part of the spin-orbit coupling.\n        n_v (int): The index of the highest valence band (in the unitcell).\n        n_b (int): The number of bands (in the unitcell).\n        lattice_name (str): The name of the lattice. The name of the matrial is obtained from `params`.\n    \"\"\"\n    self.lattice_params = VariableStorage()\n    self.orbital: LatticeOrbitals = orbital\n    self.__n_valence_band: int = n_v\n    self.__n_bands: int = n_b\n    self.__name: str = \"MoS2\"\n    self.__x_name: str = \"S\"\n    self.__x_type: str = \"X\"\n    self.__m_name: str = \"Mo\"\n    self.__m_type: str = \"M\"\n    self.__params: ParametersList = ParametersList()\n    self.__soc_eo_flip: bool = False\n    self.__lattice_name: str = lattice_name\n    self._lat4: bool = lat4\n    self.single_orbital: bool = single_orbital\n    self.soc: bool = soc\n    self.soc_polarized: bool = soc_polarized\n    self.soc_sz_part: bool = soc_sz_part\n    self.sz: float = soc_sz\n    self.params = params\n    self.soc_eo_flip = soc_eo_flip\n</code></pre>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.block_diag","title":"<code>block_diag(*matrices)</code>","text":"<p>Make a block diagonal matrix from the given matrices.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def block_diag(self, *matrices) -&gt; np.ndarray:\n    \"\"\"Make a block diagonal matrix from the given matrices.\"\"\"\n    if len(matrices) == 1:\n        return matrices[0]\n    else:\n        matrix0 = matrices[0]\n        matrix1 = self.block_diag(*matrices[1:])\n        shape_0 = np.shape(matrix0)\n        shape_1 = np.shape(matrix1)\n        z_1 = [shape_0[-2], shape_1[-1]]\n        z_2 = [shape_1[-2], shape_0[-1]]\n        nd = len(shape_0)\n        assert nd == len(shape_1), \"The matrices don't have the right sizes in the additional dimensions\"\n        if nd &gt; 2:\n            for sh in shape_1[:-2]:\n                z_1.insert(0, sh)\n                z_2.insert(0, sh)\n        return np.concatenate((np.concatenate((matrix0, np.zeros(z_1)), axis=nd - 1),\n                               np.concatenate((np.zeros(z_2), matrix1), axis=nd - 1)), axis=nd - 2)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.lattice","title":"<code>lattice()</code>","text":"<p>Make the lattice model. It returns a <code>pybinding.Lattice</code> object.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def lattice(self) -&gt; pb.Lattice:\n    \"\"\"Make the lattice model. It returns a `pybinding.Lattice` object.\"\"\"\n    lat = pb.Lattice(a1=self.a1, a2=self.a2)\n    m_orbs, m2_orbs = 0, 0\n    c_orbs, c2_orbs = 0, 0\n    if self.lattice_params.h_0_m is not None:\n        m_orbs = self._m_orbs\n        m2_orbs = self._m2_orbs\n        h_0_m = self._make_onsite(self.lattice_params.h_0_m, self.m_name, self.lattice_params.lamb_m)\n        n_m, n_c = 0, 0\n        if self.soc_eo_flip_used:\n            soc_part_m = np.zeros((5, 5)) * 1j\n            soc_part_m[3:, :3] = self.sz * self.lattice_params.lamb_m * np.array(\n                [[np.sqrt(3) / 2, -1 / 2, 1j / 2],\n                 [-1j / 2 * np.sqrt(3), -1j / 2, -1 / 2]])\n            soc_part_m[:3, 3:] = -soc_part_m[3:, :3].T\n            reorder_keys = [np.abs(np.array([0, 2, -2, 1, -1]) - key).argmin()\n                            for key in self.orbital.l_number[self.orb_type(self.m_name)]]\n            soc_part_m = self._reorder(soc_part_m, (reorder_keys, reorder_keys))\n            h_0_m[:5, 5:] = soc_part_m\n            h_0_m[5:, :5] = soc_part_m.conj().T\n\n        if self.single_orbital:\n            n_m = len(m_orbs)\n            for i_m in range(n_m):\n                lat.add_one_sublattice(m_orbs[i_m], [0, 0], np.real(h_0_m[i_m, i_m]))\n            for i_m in range(n_m):\n                for j_m in np.arange(i_m + 1, n_m):\n                    h_name = self._make_name(\"h_0_m\", 0, m_orbs[i_m], m_orbs[j_m])\n                    lat.register_hopping_energies(dict([(h_name, h_0_m[i_m, j_m])]))\n                    lat.add_one_hopping([0, 0], m_orbs[i_m], m_orbs[j_m], h_name)\n        else:\n            lat.add_one_sublattice(self.m_name, [0, 0], h_0_m)\n        if self.lat4:\n            if self.single_orbital:\n                for i_m in range(n_m):\n                    lat.add_one_sublattice(m2_orbs[i_m], [0, 0], np.real(h_0_m[i_m, i_m]))\n                for i_m in range(n_m):\n                    for j_m in np.arange(i_m + 1, n_m):\n                        h_name = self._make_name(\"h_0_m\", 0, m2_orbs[i_m], m2_orbs[j_m])\n                        lat.register_hopping_energies(dict([(h_name, h_0_m[i_m, j_m])]))\n                        lat.add_one_hopping([0, 0], m2_orbs[i_m], m2_orbs[j_m], h_name)\n            else:\n                lat.add_one_sublattice(self.m_name + \"2\",\n                                       [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 2],\n                                       h_0_m)\n\n    if self.lattice_params.h_0_c is not None:\n        h_0_c = self._make_onsite(self.lattice_params.h_0_c, self.x_name, self.lattice_params.lamb_c)\n        c_orbs = self._c_orbs\n        c2_orbs = self._c2_orbs\n        n_c = len(c_orbs)\n        if self.soc_eo_flip_used:\n            soc_part_c = np.zeros((6, 6)) * 1j\n            soc_part_c[:3, 3:] = self.sz * self.lattice_params.lamb_c * np.array(\n                [[0, 0, 1 / 2],\n                 [0, 0, -1j / 2],\n                 [-1 / 2, 1j / 2, 0]])\n            soc_part_c[3:, :3] = -soc_part_c[:3, 3:].T\n            reorder_keys1 = [np.abs(np.array([1, -1, 0]) - key).argmin()\n                             for key in self.orbital.l_number[self.orb_type(self.x_name)][:3]]\n            reorder_keys2 = [3 + np.abs(np.array([1, -1, 0]) - key).argmin()\n                             for key in self.orbital.l_number[self.orb_type(self.x_name)][3:]]\n            soc_part_c = self._reorder(soc_part_c, (reorder_keys1 + reorder_keys2, reorder_keys1 + reorder_keys2))\n            h_0_c[:6, 6:] = soc_part_c\n            h_0_c[6:, :6] = soc_part_c.conj().T\n        if self.single_orbital:\n            for i_c in range(n_c):\n                lat.add_one_sublattice(c_orbs[i_c],\n                                       [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 6],\n                                       np.real(h_0_c[i_c, i_c]))\n            for i_c in range(n_c):\n                for j_c in np.arange(i_c + 1, n_c):\n                    h_name = self._make_name(\"h_0_c\", 0, c_orbs[i_c], c_orbs[j_c])\n                    lat.register_hopping_energies(dict([(h_name, h_0_c[i_c, j_c])]))\n                    lat.add_one_hopping([0, 0], c_orbs[i_c], c_orbs[j_c], h_name)\n        else:\n            lat.add_one_sublattice(self.x_name,\n                                   [self.lattice_params.a / 2, self.lattice_params.a * np.sqrt(3) / 6],\n                                   h_0_c)\n\n        if self.lat4:\n            if self.single_orbital:\n                for i_c in range(n_c):\n                    lat.add_one_sublattice(c2_orbs[i_c],\n                                           [0, self.lattice_params.a * 2 * np.sqrt(3) / 6],\n                                           np.real(h_0_c[i_c, i_c]))\n                for i_c in range(n_c):\n                    for j_c in np.arange(i_c + 1, n_c):\n                        h_name = self._make_name(\"h_0_c\", 0, c2_orbs[i_c], c2_orbs[j_c])\n                        lat.register_hopping_energies(dict([(h_name, h_0_c[i_c, j_c])]))\n                        lat.add_one_hopping([0, 0], c2_orbs[i_c], c2_orbs[j_c], h_name)\n            else:\n                lat.add_one_sublattice(self.x_name + \"2\",\n                                       [0, self.lattice_params.a * 2 * np.sqrt(3) / 3],\n                                       h_0_c)\n\n    if self.lattice_params.h_1_m is not None:\n        cos = [[-1, -1], [0, 0], [-1, 0]] if not self.lat4 else [[0, -1], [0, 0], [0, 0], [1, 0], [-1, 0], [0, 0]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c2, c1, c1, c2, c1, c2] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name + \"2\", self.x_name, self.x_name, self.x_name + \"2\", self.x_name, self.x_name + \"2\"]\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_1_m,\n                                f_n=self.m_name,\n                                t_n=self.x_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_1_m\")\n\n    if self.lattice_params.h_2_m is not None:\n        cos = [[1, 0], [0, 1], [-1, -1]] if not self.lat4 else [[1, 0], [1, 0], [-1, 0], [0, 1], [-1, -1], [0, 0]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [[m1, m2, m2, m1, m2, m1] for (m1, m2) in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\", self.m_name + \"2\", self.m_name, self.m_name + \"2\", self.m_name]\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_2_m,\n                                f_n=self.m_name,\n                                t_n=self.m_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_2_m\")\n\n    if self.lattice_params.h_2_c is not None:\n        cos = [[1, 0], [0, 1], [-1, -1]] if not self.lat4 else [[1, 0], [1, 0], [0, 0], [-1, 1], [0, -1], [-1, 0]]\n        fnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name]\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_2_c,\n                                f_n=self.x_name,\n                                t_n=self.x_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_2_c\")\n\n    if self.lattice_params.h_3_m is not None:\n        cos = [[0, 1], [-2, -1], [0, -1]] if not self.lat4 else [[0, 0], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [ci * 3 for ci in zip(c2_orbs, c_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name + \"2\", self.x_name] * 3\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_3_m,\n                                f_n=self.m_name,\n                                t_n=self.x_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_3_m\")\n\n    if self.lattice_params.h_4_m is not None:\n        _, h_4_ma, h_4_mb = self._make_h_angle(\n            self.lattice_params.h_4_m, self.m_name, self.x_name, np.arctan(np.sqrt(3) / 5)\n        )\n        cosa = [[-1, -2], [1, 1], [-2, 0]] \\\n            if not self.lat4 else [[0, -1], [1, -1], [1, 0], [1, 1], [-2, 0], [-1, 0]]\n        cosb = [[-2, -2], [1, 0], [-1, 1]] \\\n            if not self.lat4 else [[-1, -1], [0, -1], [1, 0], [2, 0], [-1, 0], [-1, 1]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnla = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c1, c2, c2, c1, c1, c2] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name, self.x_name + \"2\"] * 3\n            )\n        )\n        tnlb = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c1, c2, c1, c2, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name] * 3\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=h_4_ma,\n                                f_n=self.m_name,\n                                t_n=self.x_name,\n                                cos=cosa,\n                                fnl=fnl,\n                                tnl=tnla,\n                                h_name=\"h_4_ma\")\n        lat = self._add_hopping(lat=lat,\n                                mat=h_4_mb,\n                                f_n=self.m_name,\n                                t_n=self.x_name,\n                                cos=cosb,\n                                fnl=fnl,\n                                tnl=tnlb,\n                                h_name=\"h_4_mb\")\n\n    if self.lattice_params.h_5_m is not None:\n        cos = [[1, 2], [-2, -1], [1, -1]] if not self.lat4 else [[0, 1], [0, 1], [-2, -1], [-1, 0], [1, -1], [2, 0]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [[m1, m2, m2, m1, m2, m1] for (m1, m2) in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\", self.m_name + \"2\", self.m_name, self.m_name + \"2\", self.m_name]\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_5_m,\n                                f_n=self.m_name,\n                                t_n=self.m_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_5_m\")\n\n    if self.lattice_params.h_5_c is not None:\n        cos = [[1, 2], [-2, -1], [1, -1]] if not self.lat4 else [[0, 1], [0, 1], [-1, -1], [-2, 0], [2, -1], [1, 0]]\n        fnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\", self.x_name + \"2\", self.x_name, self.x_name + \"2\", self.x_name]\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_5_c,\n                                f_n=self.x_name,\n                                t_n=self.x_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_5_c\")\n\n    if self.lattice_params.h_6_m is not None:\n        cos = [[2, 0], [0, 2], [-2, -2]] \\\n            if not self.lat4 else [[2, 0], [2, 0], [-1, 1], [-1, 1], [-1, -1], [-1, -1]]\n        fnl = (\n            (\n                [[m_i] * 3 for m_i in m_orbs]\n                if not self.lat4 else\n                [mi * 3 for mi in zip(m_orbs, m2_orbs)]\n            ) if self.single_orbital else (\n                [self.m_name] * 3\n                if not self.lat4 else\n                [self.m_name, self.m_name + \"2\"] * 3\n            )\n        )\n        tnl = fnl\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_6_m,\n                                f_n=self.m_name,\n                                t_n=self.m_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_6_m\")\n\n    if self.lattice_params.h_6_c is not None:\n        cos = [[2, 0], [0, 2], [-2, -2]] \\\n            if not self.lat4 else [[2, 0], [2, 0], [-1, 1], [-1, 1], [-1, -1], [-1, -1]]\n        fnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [ci * 3 for ci in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\"] * 3\n            )\n        )\n        tnl = (\n            (\n                [[c_i] * 3 for c_i in c_orbs]\n                if not self.lat4 else\n                [[c1, c2, c2, c1, c2, c1] for (c1, c2) in zip(c_orbs, c2_orbs)]\n            ) if self.single_orbital else (\n                [self.x_name] * 3\n                if not self.lat4 else\n                [self.x_name, self.x_name + \"2\"] * 3\n            )\n        )\n        lat = self._add_hopping(lat=lat,\n                                mat=self.lattice_params.h_6_c,\n                                f_n=self.x_name,\n                                t_n=self.x_name,\n                                cos=cos,\n                                fnl=fnl,\n                                tnl=tnl,\n                                h_name=\"h_6_c\")\n    return lat\n</code></pre>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.orb_type","title":"<code>orb_type(z_name)</code>","text":"<p>Return the orbital type of the atom with the given name. Usefull for the case when <code>lat4</code> is True. Returns <code>\"M\"</code> for the metal atom and <code>\"X\"</code> for the chalcogen atom.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def orb_type(self, z_name: str) -&gt; Optional[str]:\n    \"\"\"Return the orbital type of the atom with the given name. Usefull for the case when `lat4` is True.\n    Returns `\"M\"` for the metal atom and `\"X\"` for the chalcogen atom.\n    \"\"\"\n    if z_name == self.m_name or (self.lat4 and z_name == self.m_name + \"2\"):\n        return self.__m_type\n    elif z_name == self.x_name or (self.lat4 and z_name == self.x_name + \"2\"):\n        return self.__x_type\n    else:\n        return None\n</code></pre>"},{"location":"documentation/api/#tmdybinding.AbstractLattice.z_name","title":"<code>z_name(orb_type)</code>","text":"<p>Return the name of the atom with the given orbital type, for example, obtain <code>\"S\"</code> from <code>\"X\"</code> in the case the material is <code>\"MoS2\"</code>.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def z_name(self, orb_type: str) -&gt; Optional[str]:\n    \"\"\"Return the name of the atom with the given orbital type, for example, obtain `\"S\"` from `\"X\"` in the case\n    the material is `\"MoS2\"`.\n    \"\"\"\n    if orb_type == self.__m_type:\n        return self.m_name\n    elif orb_type == self.__x_type:\n        return self.x_name\n    else:\n        return None\n</code></pre>"},{"location":"documentation/api/#tmdybinding.FloatParameter","title":"<code>FloatParameter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Class to store one separate float parameter</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>@dataclass\nclass FloatParameter(Parameter):\n    \"\"\"Class to store one separate float parameter\"\"\"\n    param: Optional[float] = None\n</code></pre>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals","title":"<code>LatticeOrbitals</code>","text":"<p>Object for saving the l and s values of a lattice model.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>class LatticeOrbitals:\n    \"\"\" Object for saving the l and s values of a lattice model.\"\"\"\n\n    def __init__(self, l_number: Dict[str, List[int]], orbs: Dict[str, List[str]],\n                 group: Optional[Dict[str, List[int]]] = None, clockwise: bool = False):\n        \"\"\"Make a LatticeOrbitals object with the given combinations of l and orbs.\n        The input for `l`, `orbs` and `group` must be in the format `\"atom_name\": variables`.\n\n\n        Parameters:\n            l_number (Dict[str, List[int]]): The l-values for the orbitals.\n                The dictionary entries must be in the format `\"atom_name\": l_number`.\n                The l-values must be integers.\n                They must come in pairs of negative and positive values, except for zero.\n                Example: `{\"S\": [0, 1, -1, 0, 1, -1]}\n            orbs (Dict[str, List[str]]): The orbital names for the orbitals.\n                The dictionary entries must be in the format `\"atom_name\": orbs`.\n                The orbital names must be strings.\n                Example: `{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}`\n            group (Optional[Dict[str, List[int]]): The group of orbitals with the same l-value.\n                If multiple orbitals with the same `l` are present on one atom, you can group the similar orbitals.\n                If all the `l`-values are unique, the group is not needed.\n                The dictionary entries must be in the format `\"atom_name\": group`.\n                Example: `{\"S\": [0, 1, 1, 2, 3, 3]}`\n            clockwise (bool): If True, the rotation matrices are clockwise.\n        \"\"\"\n        self.__l_number = None\n        self.__orbs = None\n        self.__names = None\n        self.__group = None\n        self.clockwise = clockwise\n        self.set_params(l_number=l_number, orbs=orbs, group=group)\n\n    def set_params(self, l_number: Optional[Dict[str, List[int]]] = None, orbs: Optional[Dict[str, List[str]]] = None,\n                   group: Optional[Dict[str, List[int]]] = None):\n        \"\"\"Set the parameters for the lattice model.\n\n        Parameters:\n            l_number (Optional[Dict[str, List[int]]]): The l-values for the orbitals.\n                The dictionary entries must be in the format `\"atom_name\": l_number`.\n                The l-values must be integers.\n                They must come in pairs of negative and positive values, except for zero.\n                If None, the previous value is kept.\n                Example: `{\"S\": [0, 1, -1, 0, 1, -1]}\n            orbs (Optional[Dict[str, Dict[str]]]): The orbital names for the orbitals.\n                The dictionary entries must be in the format `\"atom_name\": orbs`.\n                The orbital names must be strings.\n                If None, the previous value is kept.\n                Example: `{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}`\n            group (Optional[Dict[str, List[int]]): The group of orbitals with the same l-value.\n                If multiple orbitals with the same `l` are present on one atom, you can group the similar orbitals.\n                If all the `l`-values are unique, the group is not needed.\n                If None, the previous value is kept (if there).\n                The dictionary entries must be in the format `\"atom_name\": group`.\n                Example: `{\"S\": [0, 1, 1, 2, 3, 3]}`\n        \"\"\"\n        l_pass = l_number or self.l_number\n        orbs_pass = orbs or self.orbs\n        group_pass = group or self.group\n        self._check_names(l_pass, orbs_pass, group_pass)\n        self._check_shape(l_pass, orbs_pass, group_pass)\n\n    @staticmethod\n    def _make_bools(l_number: Dict[str, List[int]], orbs: Dict[str, List[str]],\n                    group: Optional[Dict[str, List[int]]]) -&gt; Tuple[bool, bool, bool]:\n        \"\"\"Make the boolean values for the input.\n\n        Parameters:\n            l_number (Dict[str, List[int]]): The l-values for the orbitals.\n            orbs (Dict[str, List[str]]): The orbital names for the orbitals.\n            group (Optional[Dict[str, List[int]]): The group of orbitals with the same l-value.\n        \"\"\"\n        l_bool = l_number is not None\n        orbs_bool = orbs is not None\n        group_bool = group is not None\n        assert l_bool or orbs_bool, \"not enough input given, at least l or orbs needed\"\n        return l_bool, orbs_bool, group_bool\n\n    def _check_names(self, l_number: Dict[str, List[int]], orbs: Dict[str, List[str]],\n                     group: Optional[Dict[str, List[int]]]):\n        \"\"\"Check if the names of the orbitals are the same.\"\"\"\n        (l_bool, orbs_bool, group_bool) = self._make_bools(l_number, orbs, group)\n        names = None\n        if l_bool:\n            names_l = [str(name) for name in l_number.keys()]\n            names = names_l\n        if orbs_bool:\n            names_orbs = [str(name) for name in orbs.keys()]\n            if names is None:\n                names = names_orbs\n            else:\n                assert names == names_orbs, f\"the names of l_number and orbs are not the same, {names} != {names_orbs}\"\n        if group_bool:\n            names_group = [str(name) for name in group.keys()]\n            assert names == names_group, \\\n                f\"the names of l_number/orbs  and group are not the same, {names} != {names_group}\"\n        self.__names = names\n\n    def _check_shape(self, l_number: Dict[str, List[int]], orbs: Dict[str, List[str]],\n                     group: Optional[Dict[str, List[int]]]):\n        \"\"\"Check if the shape of the orbitals is correct.\"\"\"\n        (l_bool, orbs_bool, group_bool) = self._make_bools(l_number, orbs, group)\n        shape = None\n        if l_bool:\n            shape_l = [np.shape(l_number[name]) for name in self.names]\n            shape = shape_l\n        if orbs_bool:\n            shape_orbs = [np.shape(orbs[name]) for name in self.names]\n            if shape is None:\n                shape = shape_orbs\n            else:\n                assert shape == shape_orbs, f\"the shape of l_number and orbs are not the same, {shape} !m {shape_orbs}\"\n        if group_bool:\n            shape_group = [np.shape(group[name]) for name in self.names]\n            assert shape == shape_group, \"the shape of group and l_number and/or orbs are not the same\"\n\n        # see if definition of group and l are correct. If no group is specified, but there is an l, the l is checked\n        l_local = l_number if l_bool else dict([(name, np.zeros(shape[j])) for j, name in enumerate(self.names)])\n        if not group_bool:\n            for name in self.names:\n                l_num = np.array(l_local[name])\n                for lm in set(np.abs(l_num)):\n                    l_b = np.abs(l_num) == lm\n                    assert np.sum(l_b) &lt; 3, \\\n                        f\"the representation can only be given for max two parts, {np.sum(l_b)} given\"\n                    if np.sum(l_b) == 2:\n                        assert l_num[l_b][0] == -l_num[l_b][1], \\\n                            f\"can't have same l-number if group is not defined, for '{lm}'\"\n                    else:\n                        assert lm == 0, \\\n                            f\"can't have a sole l-number other than zero, '{lm}' given\"\n                    assert np.sum(l_b) == 1, \\\n                        f\"can't have a sole l-number, only one '{lm}' given\"\n        group_local = group if group_bool else dict([(name, np.abs(l_local[name])) for name in self.names])\n\n        # check l and group\n        for name in self.names:\n            group_l = np.array(group_local[name])\n            l_num = np.array(l_local[name])\n            for group_i in set(group_l):\n                group_b = group_i == group_l\n                assert np.sum(group_b) &lt; 3, \"the group for representation can only be given for max two parts\"\n                assert (np.sum(group_b) == 2 and l_num[group_b][0] == -l_num[group_b][1]) or np.sum(group_b) == 1, \\\n                    \"can't have same l-number in same group\"\n        self.__l_number = l_local\n        self.__orbs = orbs\n        self.__group = group_local\n\n    @staticmethod\n    def rot_mat(phi: float = 0) -&gt; np.ndarray:\n        \"\"\"Make a rotation matrix for the given angle.\n\n        Parameters:\n            phi (float): The angle of the rotation matrix.\n        \"\"\"\n        return np.array([[np.cos(phi), -np.sin(phi)], [np.sin(phi), np.cos(phi)]])\n\n    @property\n    def l_number(self) -&gt; Dict[str, List[int]]:\n        \"\"\"The l-values for the orbitals.\"\"\"\n        return self.__l_number\n\n    @property\n    def names(self) -&gt; List[str]:\n        \"\"\"The names of the atoms.\"\"\"\n        return self.__names\n\n    @property\n    def orbs(self) -&gt; Dict[str, List[str]]:\n        \"\"\"The orbital names for the orbitals.\"\"\"\n        return self.__orbs\n\n    @property\n    def group(self) -&gt; Dict[str, List[int]]:\n        \"\"\"The group of orbitals with the same l-value.\"\"\"\n        return self.__group\n\n    def _make_matrix(self, matrix_func, single) -&gt; Dict[str, np.ndarray]:\n        out_dict: Dict[str, np.ndarray] = {}\n        for name in self.names:\n            group_l = np.array(self.group[name])\n            l_num = np.array(self.l_number[name])\n            value = np.zeros((len(l_num), len(l_num)))\n            for group_i in set(group_l):\n                group_b = group_i == group_l\n                lm = np.abs(l_num[group_b][0])\n                sign = -1 if l_num[group_b][0] &lt; 0 else 1\n                if np.sum(group_b) == 2:\n                    matrix = matrix_func(lm, sign)\n                    for ik, k in enumerate(np.arange(len(l_num))[group_b]):\n                        for ikk, kk in enumerate(np.arange(len(l_num))[group_b]):\n                            value[k, kk] = matrix[ik, ikk]\n                else:\n                    value[np.arange(len(l_num))[group_b], np.arange(len(l_num))[group_b]] = single(lm, sign)\n            out_dict[name] = value\n        return out_dict\n\n    @property\n    def ur(self) -&gt; Dict[str, np.ndarray]:\n        \"\"\"Rotation matrix for the orbitals over an angle of 2pi/3.\n        Returns a dict of rotation matrices for the orbitals in the format `\"atom_name\": matrix`.\n        \"\"\"\n\n        def matrix_func(lm, sign):\n            ur_t = self.rot_mat(np.pi * 2 / 3 * lm)\n            if sign == -1:\n                ur_t = np.transpose(ur_t)\n            if self.clockwise:\n                ur_t = np.transpose(ur_t)\n            return ur_t\n\n        def single(lm, sign):\n            return 1 + (lm * 0 + sign * 0)\n\n        return self._make_matrix(matrix_func, single)\n\n    @property\n    def sr(self) -&gt; Dict[str, np.ndarray]:\n        \"\"\"Mirror on yz-plane.\n        Returns a dict of mirror matrices for the orbitals in the format `\"atom_name\": matrix`.\n        \"\"\"\n\n        def matrix_func(lm, sign):\n            return sign * np.diag([-1, 1]) * (1 if np.abs(lm) == 1 else -1)\n\n        def single(lm, sign):\n            return 1 + (lm * 0 + sign * 0)\n\n        return self._make_matrix(matrix_func, single)\n\n    def ur_angle(self, angle) -&gt; Dict[str, np.ndarray]:\n        \"\"\"Rotation matrix for the orbitals over an angle of `angle`.\n        Returns a dict of rotation matrices for the orbitals over an angle of `angle` in the\n        format `\"atom_name\": matrix`.\n\n        Parameters:\n            angle (float): The angle of the rotation matrix.\n        \"\"\"\n\n        def matrix_func(lm, sign):\n            ur_t = self.rot_mat(angle * lm)\n            if sign == -1:\n                ur_t = np.transpose(ur_t)\n            if self.clockwise:\n                ur_t = np.transpose(ur_t)\n            return ur_t\n\n        def single(lm, sign):\n            return 1 + (lm * 0 + sign * 0)\n\n        return self._make_matrix(matrix_func, single)\n\n    @property\n    def s_h(self):\n        \"\"\"Spin factor for the orbitals.\n        Returns a dict of spin matrices for the orbitals in the format `\"atom_name\": matrix`.\n        \"\"\"\n\n        def matrix_func(lm, sign):\n            ur_t = lm / 2 * np.array([[0, -1], [1, 0]])\n            if sign == -1:\n                ur_t = np.transpose(ur_t)\n            return ur_t\n\n        def single(lm, sign):\n            return 0 + (lm * 0 + sign * 0)\n\n        return self._make_matrix(matrix_func, single)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.group","title":"<code>group: Dict[str, List[int]]</code>  <code>property</code>","text":"<p>The group of orbitals with the same l-value.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.l_number","title":"<code>l_number: Dict[str, List[int]]</code>  <code>property</code>","text":"<p>The l-values for the orbitals.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.names","title":"<code>names: List[str]</code>  <code>property</code>","text":"<p>The names of the atoms.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.orbs","title":"<code>orbs: Dict[str, List[str]]</code>  <code>property</code>","text":"<p>The orbital names for the orbitals.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.s_h","title":"<code>s_h</code>  <code>property</code>","text":"<p>Spin factor for the orbitals. Returns a dict of spin matrices for the orbitals in the format <code>\"atom_name\": matrix</code>.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.sr","title":"<code>sr: Dict[str, np.ndarray]</code>  <code>property</code>","text":"<p>Mirror on yz-plane. Returns a dict of mirror matrices for the orbitals in the format <code>\"atom_name\": matrix</code>.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.ur","title":"<code>ur: Dict[str, np.ndarray]</code>  <code>property</code>","text":"<p>Rotation matrix for the orbitals over an angle of 2pi/3. Returns a dict of rotation matrices for the orbitals in the format <code>\"atom_name\": matrix</code>.</p>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.__init__","title":"<code>__init__(l_number, orbs, group=None, clockwise=False)</code>","text":"<p>Make a LatticeOrbitals object with the given combinations of l and orbs. The input for <code>l</code>, <code>orbs</code> and <code>group</code> must be in the format <code>\"atom_name\": variables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>l_number</code> <code>Dict[str, List[int]]</code> <p>The l-values for the orbitals. The dictionary entries must be in the format <code>\"atom_name\": l_number</code>. The l-values must be integers. They must come in pairs of negative and positive values, except for zero. Example: `{\"S\": [0, 1, -1, 0, 1, -1]}</p> required <code>orbs</code> <code>Dict[str, List[str]]</code> <p>The orbital names for the orbitals. The dictionary entries must be in the format <code>\"atom_name\": orbs</code>. The orbital names must be strings. Example: <code>{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}</code></p> required <code>group</code> <code>Optional[Dict[str, List[int]]</code> <p>The group of orbitals with the same l-value. If multiple orbitals with the same <code>l</code> are present on one atom, you can group the similar orbitals. If all the <code>l</code>-values are unique, the group is not needed. The dictionary entries must be in the format <code>\"atom_name\": group</code>. Example: <code>{\"S\": [0, 1, 1, 2, 3, 3]}</code></p> <code>None</code> <code>clockwise</code> <code>bool</code> <p>If True, the rotation matrices are clockwise.</p> <code>False</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def __init__(self, l_number: Dict[str, List[int]], orbs: Dict[str, List[str]],\n             group: Optional[Dict[str, List[int]]] = None, clockwise: bool = False):\n    \"\"\"Make a LatticeOrbitals object with the given combinations of l and orbs.\n    The input for `l`, `orbs` and `group` must be in the format `\"atom_name\": variables`.\n\n\n    Parameters:\n        l_number (Dict[str, List[int]]): The l-values for the orbitals.\n            The dictionary entries must be in the format `\"atom_name\": l_number`.\n            The l-values must be integers.\n            They must come in pairs of negative and positive values, except for zero.\n            Example: `{\"S\": [0, 1, -1, 0, 1, -1]}\n        orbs (Dict[str, List[str]]): The orbital names for the orbitals.\n            The dictionary entries must be in the format `\"atom_name\": orbs`.\n            The orbital names must be strings.\n            Example: `{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}`\n        group (Optional[Dict[str, List[int]]): The group of orbitals with the same l-value.\n            If multiple orbitals with the same `l` are present on one atom, you can group the similar orbitals.\n            If all the `l`-values are unique, the group is not needed.\n            The dictionary entries must be in the format `\"atom_name\": group`.\n            Example: `{\"S\": [0, 1, 1, 2, 3, 3]}`\n        clockwise (bool): If True, the rotation matrices are clockwise.\n    \"\"\"\n    self.__l_number = None\n    self.__orbs = None\n    self.__names = None\n    self.__group = None\n    self.clockwise = clockwise\n    self.set_params(l_number=l_number, orbs=orbs, group=group)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.rot_mat","title":"<code>rot_mat(phi=0)</code>  <code>staticmethod</code>","text":"<p>Make a rotation matrix for the given angle.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>The angle of the rotation matrix.</p> <code>0</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>@staticmethod\ndef rot_mat(phi: float = 0) -&gt; np.ndarray:\n    \"\"\"Make a rotation matrix for the given angle.\n\n    Parameters:\n        phi (float): The angle of the rotation matrix.\n    \"\"\"\n    return np.array([[np.cos(phi), -np.sin(phi)], [np.sin(phi), np.cos(phi)]])\n</code></pre>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.set_params","title":"<code>set_params(l_number=None, orbs=None, group=None)</code>","text":"<p>Set the parameters for the lattice model.</p> <p>Parameters:</p> Name Type Description Default <code>l_number</code> <code>Optional[Dict[str, List[int]]]</code> <p>The l-values for the orbitals. The dictionary entries must be in the format <code>\"atom_name\": l_number</code>. The l-values must be integers. They must come in pairs of negative and positive values, except for zero. If None, the previous value is kept. Example: `{\"S\": [0, 1, -1, 0, 1, -1]}</p> <code>None</code> <code>orbs</code> <code>Optional[Dict[str, Dict[str]]]</code> <p>The orbital names for the orbitals. The dictionary entries must be in the format <code>\"atom_name\": orbs</code>. The orbital names must be strings. If None, the previous value is kept. Example: <code>{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}</code></p> <code>None</code> <code>group</code> <code>Optional[Dict[str, List[int]]</code> <p>The group of orbitals with the same l-value. If multiple orbitals with the same <code>l</code> are present on one atom, you can group the similar orbitals. If all the <code>l</code>-values are unique, the group is not needed. If None, the previous value is kept (if there). The dictionary entries must be in the format <code>\"atom_name\": group</code>. Example: <code>{\"S\": [0, 1, 1, 2, 3, 3]}</code></p> <code>None</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def set_params(self, l_number: Optional[Dict[str, List[int]]] = None, orbs: Optional[Dict[str, List[str]]] = None,\n               group: Optional[Dict[str, List[int]]] = None):\n    \"\"\"Set the parameters for the lattice model.\n\n    Parameters:\n        l_number (Optional[Dict[str, List[int]]]): The l-values for the orbitals.\n            The dictionary entries must be in the format `\"atom_name\": l_number`.\n            The l-values must be integers.\n            They must come in pairs of negative and positive values, except for zero.\n            If None, the previous value is kept.\n            Example: `{\"S\": [0, 1, -1, 0, 1, -1]}\n        orbs (Optional[Dict[str, Dict[str]]]): The orbital names for the orbitals.\n            The dictionary entries must be in the format `\"atom_name\": orbs`.\n            The orbital names must be strings.\n            If None, the previous value is kept.\n            Example: `{\"S\": [\"pze\", \"pxe\", pye\", \"pzo\", \"pxo\", \"pyo\"]}`\n        group (Optional[Dict[str, List[int]]): The group of orbitals with the same l-value.\n            If multiple orbitals with the same `l` are present on one atom, you can group the similar orbitals.\n            If all the `l`-values are unique, the group is not needed.\n            If None, the previous value is kept (if there).\n            The dictionary entries must be in the format `\"atom_name\": group`.\n            Example: `{\"S\": [0, 1, 1, 2, 3, 3]}`\n    \"\"\"\n    l_pass = l_number or self.l_number\n    orbs_pass = orbs or self.orbs\n    group_pass = group or self.group\n    self._check_names(l_pass, orbs_pass, group_pass)\n    self._check_shape(l_pass, orbs_pass, group_pass)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.LatticeOrbitals.ur_angle","title":"<code>ur_angle(angle)</code>","text":"<p>Rotation matrix for the orbitals over an angle of <code>angle</code>. Returns a dict of rotation matrices for the orbitals over an angle of <code>angle</code> in the format <code>\"atom_name\": matrix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle of the rotation matrix.</p> required Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def ur_angle(self, angle) -&gt; Dict[str, np.ndarray]:\n    \"\"\"Rotation matrix for the orbitals over an angle of `angle`.\n    Returns a dict of rotation matrices for the orbitals over an angle of `angle` in the\n    format `\"atom_name\": matrix`.\n\n    Parameters:\n        angle (float): The angle of the rotation matrix.\n    \"\"\"\n\n    def matrix_func(lm, sign):\n        ur_t = self.rot_mat(angle * lm)\n        if sign == -1:\n            ur_t = np.transpose(ur_t)\n        if self.clockwise:\n            ur_t = np.transpose(ur_t)\n        return ur_t\n\n    def single(lm, sign):\n        return 1 + (lm * 0 + sign * 0)\n\n    return self._make_matrix(matrix_func, single)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Class to store one separate parameter</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>@dataclass\nclass Parameter:\n    \"\"\"Class to store one separate parameter\"\"\"\n    name: str = \"\"\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList","title":"<code>ParametersList</code>","text":"<p>Class to save the parameters</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>class ParametersList:\n    \"\"\"Class to save the parameters\"\"\"\n\n    def __init__(self, input_dict: Optional[Dict[str, Union[float, str]]] = None):\n        \"\"\"Initialize the parameters for the TMD lattice.\n\n        Parameters:\n            input_dict (Optional[Dict[str, Union[float, str]]]): The parameters for the TMD lattice.\n                The keys are the names of the parameters and the values are the values of the parameters.\n                The keys are:\n                `a`,            `lamb_m`,       `lamb_x`,       `material`,\n                `eps_0_x_e`, `eps_1_x_e`, `eps_0_m_e`, `eps_1_m_e`,\n                `u_1_0_m_e`, `u_1_1_m_e`, `u_1_2_m_e`, `u_1_3_m_e`, `u_1_4_m_e`,\n                `u_2_0_m_e`, `u_2_1_m_e`, `u_2_2_m_e`, `u_2_3_m_e`, `u_2_4_m_e`, `u_2_5_m_e`,\n                `u_2_0_x_e`, `u_2_1_x_e`, `u_2_2_x_e`, `u_2_3_x_e`, `u_2_4_x_e`, `u_2_5_x_e`,\n                `u_3_0_m_e`, `u_3_1_m_e`, `u_3_2_m_e`, `u_3_3_m_e`, `u_3_4_m_e`,\n                `u_4_0_m_e`, `u_4_1_m_e`, `u_4_2_m_e`, `u_4_3_m_e`, `u_4_4_m_e`,\n                `u_5_0_m_e`, `u_5_1_m_e`, `u_5_3_m_e`, `u_5_5_m_e`, `u_5_6_m_e`,\n                `u_5_0_x_e`, `u_5_2_x_e`, `u_5_3_x_e`, `u_5_5_x_e`, `u_5_6_x_e`,\n                `u_6_0_m_e`, `u_6_1_m_e`, `u_6_2_m_e`, `u_6_3_m_e`, `u_6_4_m_e`, `u_6_5_m_e`,\n                `u_6_0_x_e`, `u_6_1_x_e`, `u_6_2_x_e`, `u_6_3_x_e`, `u_6_4_x_e`, `u_6_5_x_e`,\n                `eps_0_x_o`, `eps_1_x_o`, `eps_0_m_o`,\n                `u_1_0_m_o`, `u_1_1_m_o`, `u_1_2_m_o`,\n                `u_2_0_m_o`, `u_2_1_m_o`, `u_2_2_m_o`,\n                `u_2_0_x_o`, `u_2_1_x_o`, `u_2_2_x_o`, `u_2_3_x_o`, `u_2_4_x_o`, `u_2_5_x_o`,\n                `u_3_0_m_o`, `u_3_1_m_o`, `u_3_2_m_o`,\n                `u_4_0_m_o`, `u_4_1_m_o`, `u_4_2_m_o`,\n                `u_5_0_m_o`, `u_5_2_m_o`,\n                `u_5_0_x_o`, `u_5_2_x_o`, `u_5_3_x_o`, `u_5_5_x_o`, `u_5_6_x_o`,\n                `u_6_0_m_o`, `u_6_1_m_o`, `u_6_2_m_o`,\n                `u_6_0_x_o`, `u_6_1_x_o`, `u_6_2_x_o`, `u_6_3_x_o`, `u_6_4_x_o` and `u_6_5_x_o`\n        \"\"\"\n        energy_params = [\n            *[f\"eps_{i}_x_{r}\" for i in range(2) for r in (\"e\", \"o\")],\n            *[f\"eps_{i}_m_{r}\" for i in \"0\" for r in (\"e\", \"o\")],\n            *[f\"eps_{i}_m_{r}\" for i in \"1\" for r in \"e\"],\n            *[f\"u_{u}_{i}_m_e\" for u in (\"1\", \"3\", \"4\") for i in range(5)],\n            *[f\"u_{u}_{i}_m_o\" for u in (\"1\", \"3\", \"4\") for i in range(3)],\n            *[f\"u_{u}_{i}_{m}_e\" for u in (\"2\", \"6\") for i in range(6) for m in (\"m\", \"x\")],\n            *[f\"u_{u}_{i}_x_o\" for u in (\"2\", \"6\") for i in range(6)],\n            *[f\"u_{u}_{i}_m_o\" for u in (\"2\", \"6\") for i in range(3)],\n            *[f\"u_{u}_{i}_m_e\" for u in \"5\" for i in (\"0\", \"1\", \"3\", \"5\", \"6\")],\n            *[f\"u_{u}_{i}_x_{r}\" for u in \"5\" for i in (\"0\", \"2\", \"3\", \"5\", \"6\") for r in (\"e\", \"o\")],\n            *[f\"u_{u}_{i}_m_o\" for u in \"5\" for i in (\"0\", \"2\")],\n        ]\n\n        energy_params_names = [\n            *[rf\"$\\epsilon_{i}^{{X,{r}}}$\" for i in range(2) for r in (\"e\", \"o\")],\n            *[rf\"$\\epsilon_{i}^{{M,{r}}}$\" for i in \"0\" for r in (\"e\", \"o\")],\n            *[rf\"$\\epsilon_{i}^{{M,{r}}}$\" for i in \"1\" for r in \"e\"],\n            *[rf\"$u_{u}^{{{i},e}}$\" for u in (\"1\", \"3\", \"4\") for i in range(5)],\n            *[rf\"$u_{u}^{{{i},o}}$\" for u in (\"1\", \"3\", \"4\") for i in range(3)],\n            *[rf\"$u_{u}^{{{i},{m}e}}$\" for u in (\"2\", \"6\") for i in range(6) for m in (\"M\", \"X\")],\n            *[rf\"$u_{u}^{{{i},Xo}}$\" for u in (\"2\", \"6\") for i in range(6)],\n            *[rf\"$u_{u}^{{{i},Mo}}$\" for u in (\"2\", \"6\") for i in range(3)],\n            *[rf\"$u_{u}^{{{i},Me}}$\" for u in \"5\" for i in (\"0\", \"1\", \"3\", \"5\", \"6\")],\n            *[rf\"$u_{u}^{{{i},X{r}}}$\" for u in \"5\" for i in (\"0\", \"2\", \"3\", \"5\", \"6\") for r in (\"e\", \"o\")],\n            *[rf\"$u_{u}^{{{i},Mo}}$\" for u in \"5\" for i in (\"0\", \"2\")],\n        ]\n\n        self._energy_params_dict: Dict[str, FloatParameter] = dict(zip(\n            energy_params,\n            [FloatParameter(name=p_name) for p_name in energy_params_names]\n        ))\n\n        self._general_params_dict: Dict[str, Union[FloatParameter, StringParameter]] = dict(zip(\n            [\"a\", \"lamb_m\", \"lamb_x\", \"material\"],\n            [\n                FloatParameter(param=1., name=r\"$a$\"),\n                FloatParameter(name=r\"$\\lambda_M$\"),\n                FloatParameter(name=r\"$\\lambda_X$\"),\n                StringParameter(name=\"material\")\n            ]\n        ))\n        if input_dict is not None:\n            self.from_dict(input_dict)\n\n    @property\n    def _unique_params_dict(self) -&gt; List[dict]:\n        return [self._general_params_dict, self._energy_params_dict]\n\n    @property\n    def _protected_params_dict(self) -&gt; Optional[List[dict]]:\n        return None\n\n    @property\n    def _all_params_dict(self) -&gt; List[dict]:\n        return self._unique_params_dict + (self._protected_params_dict or [])\n\n    @property\n    def _allowed_params(self):\n        return [param_key for param_dict in self._all_params_dict for param_key in param_dict.keys()]\n\n    def _check_key(self, key) -&gt; bool:\n        if key not in self._allowed_params:\n            assert False\n            warnings.warn(f\"Variable {key} is not an expected variable, it is ignored\", UserWarning, stacklevel=2)\n            return False\n        return True\n\n    def __setitem__(self, key, value):\n        if self._check_key(key):\n            for param_dict in self._unique_params_dict:\n                if key in param_dict.keys():\n                    param_dict[key].param = value\n                    return\n            if self._protected_params_dict is not None:\n                for param_dict in self._protected_params_dict:\n                    if key in param_dict.keys():\n                        param_dict[key].param = value\n                        warnings.warn(f\"The variable {key} is read-only, you should not change it.\", UserWarning, stacklevel=2)\n                        return\n            warnings.warn(f\"This should not happen, {key} should be a valid key.\", UserWarning, stacklevel=2)\n\n    def __getitem__(self, item) -&gt; Union[float, str]:\n        return self.get_param(item) or 0.0\n\n    def get_dict(self) -&gt; dict:\n        \"\"\"Function to get the variables as a dict.\"\"\"\n        out_dict = {}\n        for param_dict in self._unique_params_dict:\n            for key, item in param_dict.items():\n                if item.param is not None:\n                    out_dict[key] = item.param\n        return out_dict\n\n    def get_param(self, key):\n        \"\"\"Function to get the specific variable\"\"\"\n        if self._check_key(key):\n            for param_dict in self._all_params_dict:\n                if key in param_dict.keys():\n                    return param_dict[key].param\n            warnings.warn(f\"This should not happen, {key} should be a valid key.\", UserWarning, stacklevel=2)\n\n    def get_name(self, key) -&gt; str:\n        \"\"\"Function to get the name (in LaTeX) of the specific variable\"\"\"\n        if self._check_key(key):\n            for param_dict in self._all_params_dict:\n                if key in param_dict.keys():\n                    return param_dict[key].name\n            warnings.warn(f\"This should not happen, {key} should be a valid key.\", UserWarning, stacklevel=2)\n\n    def from_dict(self, input_dict: Dict[str, Union[float, str]]):\n        \"\"\"Function to set the variables with a dict.\n\n        Parameters:\n            input_dict (dict): The dictionary containing the parameters for the TMD lattice.\n                The allowed keys are:\n                `a`,            `lamb_m`,       `lamb_x`,       `material`,\n                `eps_0_x_e`, `eps_1_x_e`, `eps_0_m_e`, `eps_1_m_e`,\n                `u_1_0_m_e`, `u_1_1_m_e`, `u_1_2_m_e`, `u_1_3_m_e`, `u_1_4_m_e`,\n                `u_2_0_m_e`, `u_2_1_m_e`, `u_2_2_m_e`, `u_2_3_m_e`, `u_2_4_m_e`, `u_2_5_m_e`,\n                `u_2_0_x_e`, `u_2_1_x_e`, `u_2_2_x_e`, `u_2_3_x_e`, `u_2_4_x_e`, `u_2_5_x_e`,\n                `u_3_0_m_e`, `u_3_1_m_e`, `u_3_2_m_e`, `u_3_3_m_e`, `u_3_4_m_e`,\n                `u_4_0_m_e`, `u_4_1_m_e`, `u_4_2_m_e`, `u_4_3_m_e`, `u_4_4_m_e`,\n                `u_5_0_m_e`, `u_5_1_m_e`, `u_5_3_m_e`, `u_5_5_m_e`, `u_5_6_m_e`,\n                `u_5_0_x_e`, `u_5_2_x_e`, `u_5_3_x_e`, `u_5_5_x_e`, `u_5_6_x_e`,\n                `u_6_0_m_e`, `u_6_1_m_e`, `u_6_2_m_e`, `u_6_3_m_e`, `u_6_4_m_e`, `u_6_5_m_e`,\n                `u_6_0_x_e`, `u_6_1_x_e`, `u_6_2_x_e`, `u_6_3_x_e`, `u_6_4_x_e`, `u_6_5_x_e`,\n                `eps_0_x_o`, `eps_1_x_o`, `eps_0_m_o`,\n                `u_1_0_m_o`, `u_1_1_m_o`, `u_1_2_m_o`,\n                `u_2_0_m_o`, `u_2_1_m_o`, `u_2_2_m_o`,\n                `u_2_0_x_o`, `u_2_1_x_o`, `u_2_2_x_o`, `u_2_3_x_o`, `u_2_4_x_o`, `u_2_5_x_o`,\n                `u_3_0_m_o`, `u_3_1_m_o`, `u_3_2_m_o`,\n                `u_4_0_m_o`, `u_4_1_m_o`, `u_4_2_m_o`,\n                `u_5_0_m_o`, `u_5_2_m_o`,\n                `u_5_0_x_o`, `u_5_2_x_o`, `u_5_3_x_o`, `u_5_5_x_o`, `u_5_6_x_o`,\n                `u_6_0_m_o`, `u_6_1_m_o`, `u_6_2_m_o`,\n                `u_6_0_x_o`, `u_6_1_x_o`, `u_6_2_x_o`, `u_6_3_x_o`, `u_6_4_x_o` and `u_6_5_x_o`\n        \"\"\"\n        for param_name, value in input_dict.items():\n            self[param_name] = value\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList.__init__","title":"<code>__init__(input_dict=None)</code>","text":"<p>Initialize the parameters for the TMD lattice.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Optional[Dict[str, Union[float, str]]]</code> <p>The parameters for the TMD lattice. The keys are the names of the parameters and the values are the values of the parameters. The keys are: <code>a</code>,            <code>lamb_m</code>,       <code>lamb_x</code>,       <code>material</code>, <code>eps_0_x_e</code>, <code>eps_1_x_e</code>, <code>eps_0_m_e</code>, <code>eps_1_m_e</code>, <code>u_1_0_m_e</code>, <code>u_1_1_m_e</code>, <code>u_1_2_m_e</code>, <code>u_1_3_m_e</code>, <code>u_1_4_m_e</code>, <code>u_2_0_m_e</code>, <code>u_2_1_m_e</code>, <code>u_2_2_m_e</code>, <code>u_2_3_m_e</code>, <code>u_2_4_m_e</code>, <code>u_2_5_m_e</code>, <code>u_2_0_x_e</code>, <code>u_2_1_x_e</code>, <code>u_2_2_x_e</code>, <code>u_2_3_x_e</code>, <code>u_2_4_x_e</code>, <code>u_2_5_x_e</code>, <code>u_3_0_m_e</code>, <code>u_3_1_m_e</code>, <code>u_3_2_m_e</code>, <code>u_3_3_m_e</code>, <code>u_3_4_m_e</code>, <code>u_4_0_m_e</code>, <code>u_4_1_m_e</code>, <code>u_4_2_m_e</code>, <code>u_4_3_m_e</code>, <code>u_4_4_m_e</code>, <code>u_5_0_m_e</code>, <code>u_5_1_m_e</code>, <code>u_5_3_m_e</code>, <code>u_5_5_m_e</code>, <code>u_5_6_m_e</code>, <code>u_5_0_x_e</code>, <code>u_5_2_x_e</code>, <code>u_5_3_x_e</code>, <code>u_5_5_x_e</code>, <code>u_5_6_x_e</code>, <code>u_6_0_m_e</code>, <code>u_6_1_m_e</code>, <code>u_6_2_m_e</code>, <code>u_6_3_m_e</code>, <code>u_6_4_m_e</code>, <code>u_6_5_m_e</code>, <code>u_6_0_x_e</code>, <code>u_6_1_x_e</code>, <code>u_6_2_x_e</code>, <code>u_6_3_x_e</code>, <code>u_6_4_x_e</code>, <code>u_6_5_x_e</code>, <code>eps_0_x_o</code>, <code>eps_1_x_o</code>, <code>eps_0_m_o</code>, <code>u_1_0_m_o</code>, <code>u_1_1_m_o</code>, <code>u_1_2_m_o</code>, <code>u_2_0_m_o</code>, <code>u_2_1_m_o</code>, <code>u_2_2_m_o</code>, <code>u_2_0_x_o</code>, <code>u_2_1_x_o</code>, <code>u_2_2_x_o</code>, <code>u_2_3_x_o</code>, <code>u_2_4_x_o</code>, <code>u_2_5_x_o</code>, <code>u_3_0_m_o</code>, <code>u_3_1_m_o</code>, <code>u_3_2_m_o</code>, <code>u_4_0_m_o</code>, <code>u_4_1_m_o</code>, <code>u_4_2_m_o</code>, <code>u_5_0_m_o</code>, <code>u_5_2_m_o</code>, <code>u_5_0_x_o</code>, <code>u_5_2_x_o</code>, <code>u_5_3_x_o</code>, <code>u_5_5_x_o</code>, <code>u_5_6_x_o</code>, <code>u_6_0_m_o</code>, <code>u_6_1_m_o</code>, <code>u_6_2_m_o</code>, <code>u_6_0_x_o</code>, <code>u_6_1_x_o</code>, <code>u_6_2_x_o</code>, <code>u_6_3_x_o</code>, <code>u_6_4_x_o</code> and <code>u_6_5_x_o</code></p> <code>None</code> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>def __init__(self, input_dict: Optional[Dict[str, Union[float, str]]] = None):\n    \"\"\"Initialize the parameters for the TMD lattice.\n\n    Parameters:\n        input_dict (Optional[Dict[str, Union[float, str]]]): The parameters for the TMD lattice.\n            The keys are the names of the parameters and the values are the values of the parameters.\n            The keys are:\n            `a`,            `lamb_m`,       `lamb_x`,       `material`,\n            `eps_0_x_e`, `eps_1_x_e`, `eps_0_m_e`, `eps_1_m_e`,\n            `u_1_0_m_e`, `u_1_1_m_e`, `u_1_2_m_e`, `u_1_3_m_e`, `u_1_4_m_e`,\n            `u_2_0_m_e`, `u_2_1_m_e`, `u_2_2_m_e`, `u_2_3_m_e`, `u_2_4_m_e`, `u_2_5_m_e`,\n            `u_2_0_x_e`, `u_2_1_x_e`, `u_2_2_x_e`, `u_2_3_x_e`, `u_2_4_x_e`, `u_2_5_x_e`,\n            `u_3_0_m_e`, `u_3_1_m_e`, `u_3_2_m_e`, `u_3_3_m_e`, `u_3_4_m_e`,\n            `u_4_0_m_e`, `u_4_1_m_e`, `u_4_2_m_e`, `u_4_3_m_e`, `u_4_4_m_e`,\n            `u_5_0_m_e`, `u_5_1_m_e`, `u_5_3_m_e`, `u_5_5_m_e`, `u_5_6_m_e`,\n            `u_5_0_x_e`, `u_5_2_x_e`, `u_5_3_x_e`, `u_5_5_x_e`, `u_5_6_x_e`,\n            `u_6_0_m_e`, `u_6_1_m_e`, `u_6_2_m_e`, `u_6_3_m_e`, `u_6_4_m_e`, `u_6_5_m_e`,\n            `u_6_0_x_e`, `u_6_1_x_e`, `u_6_2_x_e`, `u_6_3_x_e`, `u_6_4_x_e`, `u_6_5_x_e`,\n            `eps_0_x_o`, `eps_1_x_o`, `eps_0_m_o`,\n            `u_1_0_m_o`, `u_1_1_m_o`, `u_1_2_m_o`,\n            `u_2_0_m_o`, `u_2_1_m_o`, `u_2_2_m_o`,\n            `u_2_0_x_o`, `u_2_1_x_o`, `u_2_2_x_o`, `u_2_3_x_o`, `u_2_4_x_o`, `u_2_5_x_o`,\n            `u_3_0_m_o`, `u_3_1_m_o`, `u_3_2_m_o`,\n            `u_4_0_m_o`, `u_4_1_m_o`, `u_4_2_m_o`,\n            `u_5_0_m_o`, `u_5_2_m_o`,\n            `u_5_0_x_o`, `u_5_2_x_o`, `u_5_3_x_o`, `u_5_5_x_o`, `u_5_6_x_o`,\n            `u_6_0_m_o`, `u_6_1_m_o`, `u_6_2_m_o`,\n            `u_6_0_x_o`, `u_6_1_x_o`, `u_6_2_x_o`, `u_6_3_x_o`, `u_6_4_x_o` and `u_6_5_x_o`\n    \"\"\"\n    energy_params = [\n        *[f\"eps_{i}_x_{r}\" for i in range(2) for r in (\"e\", \"o\")],\n        *[f\"eps_{i}_m_{r}\" for i in \"0\" for r in (\"e\", \"o\")],\n        *[f\"eps_{i}_m_{r}\" for i in \"1\" for r in \"e\"],\n        *[f\"u_{u}_{i}_m_e\" for u in (\"1\", \"3\", \"4\") for i in range(5)],\n        *[f\"u_{u}_{i}_m_o\" for u in (\"1\", \"3\", \"4\") for i in range(3)],\n        *[f\"u_{u}_{i}_{m}_e\" for u in (\"2\", \"6\") for i in range(6) for m in (\"m\", \"x\")],\n        *[f\"u_{u}_{i}_x_o\" for u in (\"2\", \"6\") for i in range(6)],\n        *[f\"u_{u}_{i}_m_o\" for u in (\"2\", \"6\") for i in range(3)],\n        *[f\"u_{u}_{i}_m_e\" for u in \"5\" for i in (\"0\", \"1\", \"3\", \"5\", \"6\")],\n        *[f\"u_{u}_{i}_x_{r}\" for u in \"5\" for i in (\"0\", \"2\", \"3\", \"5\", \"6\") for r in (\"e\", \"o\")],\n        *[f\"u_{u}_{i}_m_o\" for u in \"5\" for i in (\"0\", \"2\")],\n    ]\n\n    energy_params_names = [\n        *[rf\"$\\epsilon_{i}^{{X,{r}}}$\" for i in range(2) for r in (\"e\", \"o\")],\n        *[rf\"$\\epsilon_{i}^{{M,{r}}}$\" for i in \"0\" for r in (\"e\", \"o\")],\n        *[rf\"$\\epsilon_{i}^{{M,{r}}}$\" for i in \"1\" for r in \"e\"],\n        *[rf\"$u_{u}^{{{i},e}}$\" for u in (\"1\", \"3\", \"4\") for i in range(5)],\n        *[rf\"$u_{u}^{{{i},o}}$\" for u in (\"1\", \"3\", \"4\") for i in range(3)],\n        *[rf\"$u_{u}^{{{i},{m}e}}$\" for u in (\"2\", \"6\") for i in range(6) for m in (\"M\", \"X\")],\n        *[rf\"$u_{u}^{{{i},Xo}}$\" for u in (\"2\", \"6\") for i in range(6)],\n        *[rf\"$u_{u}^{{{i},Mo}}$\" for u in (\"2\", \"6\") for i in range(3)],\n        *[rf\"$u_{u}^{{{i},Me}}$\" for u in \"5\" for i in (\"0\", \"1\", \"3\", \"5\", \"6\")],\n        *[rf\"$u_{u}^{{{i},X{r}}}$\" for u in \"5\" for i in (\"0\", \"2\", \"3\", \"5\", \"6\") for r in (\"e\", \"o\")],\n        *[rf\"$u_{u}^{{{i},Mo}}$\" for u in \"5\" for i in (\"0\", \"2\")],\n    ]\n\n    self._energy_params_dict: Dict[str, FloatParameter] = dict(zip(\n        energy_params,\n        [FloatParameter(name=p_name) for p_name in energy_params_names]\n    ))\n\n    self._general_params_dict: Dict[str, Union[FloatParameter, StringParameter]] = dict(zip(\n        [\"a\", \"lamb_m\", \"lamb_x\", \"material\"],\n        [\n            FloatParameter(param=1., name=r\"$a$\"),\n            FloatParameter(name=r\"$\\lambda_M$\"),\n            FloatParameter(name=r\"$\\lambda_X$\"),\n            StringParameter(name=\"material\")\n        ]\n    ))\n    if input_dict is not None:\n        self.from_dict(input_dict)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList.from_dict","title":"<code>from_dict(input_dict)</code>","text":"<p>Function to set the variables with a dict.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>The dictionary containing the parameters for the TMD lattice. The allowed keys are: <code>a</code>,            <code>lamb_m</code>,       <code>lamb_x</code>,       <code>material</code>, <code>eps_0_x_e</code>, <code>eps_1_x_e</code>, <code>eps_0_m_e</code>, <code>eps_1_m_e</code>, <code>u_1_0_m_e</code>, <code>u_1_1_m_e</code>, <code>u_1_2_m_e</code>, <code>u_1_3_m_e</code>, <code>u_1_4_m_e</code>, <code>u_2_0_m_e</code>, <code>u_2_1_m_e</code>, <code>u_2_2_m_e</code>, <code>u_2_3_m_e</code>, <code>u_2_4_m_e</code>, <code>u_2_5_m_e</code>, <code>u_2_0_x_e</code>, <code>u_2_1_x_e</code>, <code>u_2_2_x_e</code>, <code>u_2_3_x_e</code>, <code>u_2_4_x_e</code>, <code>u_2_5_x_e</code>, <code>u_3_0_m_e</code>, <code>u_3_1_m_e</code>, <code>u_3_2_m_e</code>, <code>u_3_3_m_e</code>, <code>u_3_4_m_e</code>, <code>u_4_0_m_e</code>, <code>u_4_1_m_e</code>, <code>u_4_2_m_e</code>, <code>u_4_3_m_e</code>, <code>u_4_4_m_e</code>, <code>u_5_0_m_e</code>, <code>u_5_1_m_e</code>, <code>u_5_3_m_e</code>, <code>u_5_5_m_e</code>, <code>u_5_6_m_e</code>, <code>u_5_0_x_e</code>, <code>u_5_2_x_e</code>, <code>u_5_3_x_e</code>, <code>u_5_5_x_e</code>, <code>u_5_6_x_e</code>, <code>u_6_0_m_e</code>, <code>u_6_1_m_e</code>, <code>u_6_2_m_e</code>, <code>u_6_3_m_e</code>, <code>u_6_4_m_e</code>, <code>u_6_5_m_e</code>, <code>u_6_0_x_e</code>, <code>u_6_1_x_e</code>, <code>u_6_2_x_e</code>, <code>u_6_3_x_e</code>, <code>u_6_4_x_e</code>, <code>u_6_5_x_e</code>, <code>eps_0_x_o</code>, <code>eps_1_x_o</code>, <code>eps_0_m_o</code>, <code>u_1_0_m_o</code>, <code>u_1_1_m_o</code>, <code>u_1_2_m_o</code>, <code>u_2_0_m_o</code>, <code>u_2_1_m_o</code>, <code>u_2_2_m_o</code>, <code>u_2_0_x_o</code>, <code>u_2_1_x_o</code>, <code>u_2_2_x_o</code>, <code>u_2_3_x_o</code>, <code>u_2_4_x_o</code>, <code>u_2_5_x_o</code>, <code>u_3_0_m_o</code>, <code>u_3_1_m_o</code>, <code>u_3_2_m_o</code>, <code>u_4_0_m_o</code>, <code>u_4_1_m_o</code>, <code>u_4_2_m_o</code>, <code>u_5_0_m_o</code>, <code>u_5_2_m_o</code>, <code>u_5_0_x_o</code>, <code>u_5_2_x_o</code>, <code>u_5_3_x_o</code>, <code>u_5_5_x_o</code>, <code>u_5_6_x_o</code>, <code>u_6_0_m_o</code>, <code>u_6_1_m_o</code>, <code>u_6_2_m_o</code>, <code>u_6_0_x_o</code>, <code>u_6_1_x_o</code>, <code>u_6_2_x_o</code>, <code>u_6_3_x_o</code>, <code>u_6_4_x_o</code> and <code>u_6_5_x_o</code></p> required Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>def from_dict(self, input_dict: Dict[str, Union[float, str]]):\n    \"\"\"Function to set the variables with a dict.\n\n    Parameters:\n        input_dict (dict): The dictionary containing the parameters for the TMD lattice.\n            The allowed keys are:\n            `a`,            `lamb_m`,       `lamb_x`,       `material`,\n            `eps_0_x_e`, `eps_1_x_e`, `eps_0_m_e`, `eps_1_m_e`,\n            `u_1_0_m_e`, `u_1_1_m_e`, `u_1_2_m_e`, `u_1_3_m_e`, `u_1_4_m_e`,\n            `u_2_0_m_e`, `u_2_1_m_e`, `u_2_2_m_e`, `u_2_3_m_e`, `u_2_4_m_e`, `u_2_5_m_e`,\n            `u_2_0_x_e`, `u_2_1_x_e`, `u_2_2_x_e`, `u_2_3_x_e`, `u_2_4_x_e`, `u_2_5_x_e`,\n            `u_3_0_m_e`, `u_3_1_m_e`, `u_3_2_m_e`, `u_3_3_m_e`, `u_3_4_m_e`,\n            `u_4_0_m_e`, `u_4_1_m_e`, `u_4_2_m_e`, `u_4_3_m_e`, `u_4_4_m_e`,\n            `u_5_0_m_e`, `u_5_1_m_e`, `u_5_3_m_e`, `u_5_5_m_e`, `u_5_6_m_e`,\n            `u_5_0_x_e`, `u_5_2_x_e`, `u_5_3_x_e`, `u_5_5_x_e`, `u_5_6_x_e`,\n            `u_6_0_m_e`, `u_6_1_m_e`, `u_6_2_m_e`, `u_6_3_m_e`, `u_6_4_m_e`, `u_6_5_m_e`,\n            `u_6_0_x_e`, `u_6_1_x_e`, `u_6_2_x_e`, `u_6_3_x_e`, `u_6_4_x_e`, `u_6_5_x_e`,\n            `eps_0_x_o`, `eps_1_x_o`, `eps_0_m_o`,\n            `u_1_0_m_o`, `u_1_1_m_o`, `u_1_2_m_o`,\n            `u_2_0_m_o`, `u_2_1_m_o`, `u_2_2_m_o`,\n            `u_2_0_x_o`, `u_2_1_x_o`, `u_2_2_x_o`, `u_2_3_x_o`, `u_2_4_x_o`, `u_2_5_x_o`,\n            `u_3_0_m_o`, `u_3_1_m_o`, `u_3_2_m_o`,\n            `u_4_0_m_o`, `u_4_1_m_o`, `u_4_2_m_o`,\n            `u_5_0_m_o`, `u_5_2_m_o`,\n            `u_5_0_x_o`, `u_5_2_x_o`, `u_5_3_x_o`, `u_5_5_x_o`, `u_5_6_x_o`,\n            `u_6_0_m_o`, `u_6_1_m_o`, `u_6_2_m_o`,\n            `u_6_0_x_o`, `u_6_1_x_o`, `u_6_2_x_o`, `u_6_3_x_o`, `u_6_4_x_o` and `u_6_5_x_o`\n    \"\"\"\n    for param_name, value in input_dict.items():\n        self[param_name] = value\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList.get_dict","title":"<code>get_dict()</code>","text":"<p>Function to get the variables as a dict.</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>def get_dict(self) -&gt; dict:\n    \"\"\"Function to get the variables as a dict.\"\"\"\n    out_dict = {}\n    for param_dict in self._unique_params_dict:\n        for key, item in param_dict.items():\n            if item.param is not None:\n                out_dict[key] = item.param\n    return out_dict\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList.get_name","title":"<code>get_name(key)</code>","text":"<p>Function to get the name (in LaTeX) of the specific variable</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>def get_name(self, key) -&gt; str:\n    \"\"\"Function to get the name (in LaTeX) of the specific variable\"\"\"\n    if self._check_key(key):\n        for param_dict in self._all_params_dict:\n            if key in param_dict.keys():\n                return param_dict[key].name\n        warnings.warn(f\"This should not happen, {key} should be a valid key.\", UserWarning, stacklevel=2)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.ParametersList.get_param","title":"<code>get_param(key)</code>","text":"<p>Function to get the specific variable</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>def get_param(self, key):\n    \"\"\"Function to get the specific variable\"\"\"\n    if self._check_key(key):\n        for param_dict in self._all_params_dict:\n            if key in param_dict.keys():\n                return param_dict[key].param\n        warnings.warn(f\"This should not happen, {key} should be a valid key.\", UserWarning, stacklevel=2)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKParametersList","title":"<code>SKParametersList</code>","text":"<p>               Bases: <code>ParametersList</code></p> <p>Class to store the parameters for SK e/o model</p> Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>class SKParametersList(ParametersList):\n    \"\"\"Class to store the parameters for SK e/o model\"\"\"\n\n    def __init__(self, input_dict: Optional[Dict[str, Union[str, Optional[float]]]] = None):\n        \"\"\"Initialize the SK parameters\n\n        Parameters:\n            input_dict (dict): The dictionary containing the SK parameters. The keys are the parameter names and the\n                values are the parameter values. The keys are:\n                `a`, `lamb_x`, `lamb_m`, `material`, `theta`,\n                `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n                `v_0_pps`, `v_0_ppp`,\n                `v_1_e_pds`, `v_1_e_pdp`, `v_1_o_pds`, `v_1_o_pdp`,\n                `v_2_e_pps`, `v_2_e_ppp`, `v_2_e_pps_tb`, `v_2_e_ppp_tb`,\n                `v_2_o_pps`, `v_2_o_ppp`, `v_2_o_pps_tb`, `v_2_o_ppp_tb`,\n                `v_2_e_dds`, `v_2_e_ddp`, `v_2_e_ddd`,\n                `v_2_o_ddp`, `v_2_o_ddd`,\n                `v_3_e_pds`, `v_3_e_pdp`, `v_3_o_pds`, `v_3_o_pdp`,\n                `v_4_e_pds`, `v_4_e_pdp`, `v_4_o_pds`, `v_4_o_pdp`,\n                `v_5_e_pps`, `v_5_e_ppp`, `v_5_e_pps_tb`, `v_5_e_ppp_tb`,\n                `v_5_o_pps`, `v_5_o_ppp`, `v_5_o_pps_tb`, `v_5_o_ppp_tb`,\n                `v_5_e_dds`, `v_5_e_ddp`, `v_5_e_ddd`,\n                `v_5_o_ddp`, `v_5_o_ddd`,\n                `v_6_e_pps`, `v_6_e_ppp`, `v_6_e_pps_tb`, `v_6_e_ppp_tb`,\n                `v_6_o_pps`, `v_6_o_ppp`, `v_6_o_pps_tb`, `v_6_o_ppp_tb`,\n                `v_6_e_dds`, `v_6_e_ddp`, `v_6_e_ddd`,\n                `v_6_o_ddp` and `v_6_o_ddd`\"\"\"\n        super().__init__(None)\n        self._recalculate_params_bool: bool = True\n        self._tan_theta: Optional[float] = None\n\n        onsite_sk_params = [\n            \"theta\",\n            *[f\"delta_{r}\" for r in (\"p\", \"z\", \"0\", \"1\", \"2\")],\n            *[f\"v_0_pp{r}\" for r in (\"s\", \"p\")]\n        ]\n        onsite_sk_params_names = [\n            r\"$\\theta$\",\n            *[rf\"$\\delta_{r}$\" for r in (\"p\", \"z\", \"0\", \"1\", \"2\")],\n            *[rf\"$V^0_{{pp{r}}}$\" for r in (r\"\\sigma\", r\"\\pi\")],\n        ]\n\n        self._onsite_sk_params_dict: dict = dict(zip(\n            onsite_sk_params,\n            [FloatParameter(name=p_name) for p_name in onsite_sk_params_names]\n        ))\n\n        sk_params = [\n            *[f\"v_{n}_{r}_pd{i}\" for n in (\"1\", \"3\", \"4\") for r in (\"e\", \"o\") for i in (\"s\", \"p\")],\n            *[f\"v_{n}_{r}_pp{i}{t}\" for n in (\"2\", \"5\", \"6\")\n              for r in (\"e\", \"o\") for i in (\"s\", \"p\") for t in (\"\", \"_tb\")],\n            *[f\"v_{n}_e_dds\" for n in (\"2\", \"5\", \"6\")],\n            *[f\"v_{n}_{r}_dd{i}\" for n in (\"2\", \"5\", \"6\") for r in (\"e\", \"o\") for i in (\"p\", \"d\")]\n        ]\n\n        sk_params_names = [\n            *[rf\"$V^{{{n}_{r}}}_{{pd{i}}}$\" for n in (\"1\", \"3\", \"4\") for r in (\"e\", \"o\") for i in (r\"\\sigma\", r\"\\pi\")],\n            *[rf\"$V^{{{n}_{r}}}_{{pp{i}{t}}}$\" for n in (\"2\", \"5\", \"6\")\n              for r in (\"e\", \"o\") for i in (r\"\\sigma\", r\"\\pi\") for t in (\"\", \",tb\")],\n            *[rf\"$V^{{{n}_e}}_{{dd\\sigmas}}$\" for n in (\"2\", \"5\", \"6\")],\n            *[rf\"$V^{{{n}_{r}}}_{{dd{i}}}$\" for n in (\"2\", \"5\", \"6\") for r in (\"e\", \"o\") for i in (r\"\\pi\", r\"\\delta\")]\n        ]\n        self._sk_params_dict: dict = dict(zip(\n            sk_params,\n            [FloatParameter(name=p_name) for p_name in sk_params_names]\n        ))\n\n        if input_dict is not None:\n            self.from_dict(input_dict)\n\n    @property\n    def _unique_params_dict(self) -&gt; List[dict]:\n        return [self._general_params_dict, self._onsite_sk_params_dict, self._sk_params_dict]\n\n    @property\n    def _protected_params_dict(self) -&gt; Optional[List[dict]]:\n        return [self._energy_params_dict]\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value of a parameter and recalculate the parameters.\"\"\"\n        super().__setitem__(key, value)\n        self._recalculate_params()\n\n    def from_dict(self, input_dict: Dict[str, Union[float, str]]):\n        \"\"\"Set the parameters from a dictionary and recalculate the parameters.\n\n        Parameters:\n            input_dict (dict): The dictionary containing the SK parameters. The keys are the parameter names and the\n                values are the parameter values. The keys are:\n                `a`, `lamb_x`, `lamb_m`, `material`, `theta`,\n                `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n                `v_0_pps`, `v_0_ppp`,\n                `v_1_e_pds`, `v_1_e_pdp`, `v_1_o_pds`, `v_1_o_pdp`,\n                `v_2_e_pps`, `v_2_e_ppp`, `v_2_e_pps_tb`, `v_2_e_ppp_tb`,\n                `v_2_o_pps`, `v_2_o_ppp`, `v_2_o_pps_tb`, `v_2_o_ppp_tb`,\n                `v_2_e_dds`, `v_2_e_ddp`, `v_2_e_ddd`,\n                `v_2_o_ddp`, `v_2_o_ddd`,\n                `v_3_e_pds`, `v_3_e_pdp`, `v_3_o_pds`, `v_3_o_pdp`,\n                `v_4_e_pds`, `v_4_e_pdp`, `v_4_o_pds`, `v_4_o_pdp`,\n                `v_5_e_pps`, `v_5_e_ppp`, `v_5_e_pps_tb`, `v_5_e_ppp_tb`,\n                `v_5_o_pps`, `v_5_o_ppp`, `v_5_o_pps_tb`, `v_5_o_ppp_tb`,\n                `v_5_e_dds`, `v_5_e_ddp`, `v_5_e_ddd`,\n                `v_5_o_ddp`, `v_5_o_ddd`,\n                `v_6_e_pps`, `v_6_e_ppp`, `v_6_e_pps_tb`, `v_6_e_ppp_tb`,\n                `v_6_o_pps`, `v_6_o_ppp`, `v_6_o_pps_tb`, `v_6_o_ppp_tb`,\n                `v_6_e_dds`, `v_6_e_ddp`, `v_6_e_ddd`,\n                `v_6_o_ddp` and `v_6_o_ddd`\"\"\"\n        self._recalculate_params_bool = False\n        super().from_dict(input_dict)\n        self._recalculate_params_bool = True\n        self._recalculate_params()\n\n    def _recalculate_params(self):\n        if self._recalculate_params_bool:\n            self._tan_theta = np.tan(self[\"theta\"]) if self[\"theta\"] is not None else np.sqrt(3 / 4)\n            # Onsite elements\n            # X\n            self._energy_params_dict[\"eps_0_x_e\"].param = self._comb_nonefloat([self[\"delta_p\"], self[\"v_0_ppp\"]])\n            self._energy_params_dict[\"eps_1_x_e\"].param = self._subtract_param(self[\"delta_z\"], self[\"v_0_pps\"])\n            self._energy_params_dict[\"eps_0_x_o\"].param = self._subtract_param(self[\"delta_p\"], self[\"v_0_ppp\"])\n            self._energy_params_dict[\"eps_1_x_o\"].param = self._comb_nonefloat([self[\"delta_z\"], self[\"v_0_pps\"]])\n            # M\n            self._energy_params_dict[\"eps_0_m_e\"].param = self[\"delta_0\"]\n            self._energy_params_dict[\"eps_1_m_e\"].param = self[\"delta_2\"]\n            self._energy_params_dict[\"eps_0_m_o\"].param = self[\"delta_1\"]\n            # h1\n            [\n                self._energy_params_dict[\"u_1_0_m_e\"].param,\n                self._energy_params_dict[\"u_1_1_m_e\"].param,\n                self._energy_params_dict[\"u_1_2_m_e\"].param,\n                self._energy_params_dict[\"u_1_3_m_e\"].param,\n                self._energy_params_dict[\"u_1_4_m_e\"].param\n            ] = self._h_mx_e(r=-1, vpds=self[\"v_1_e_pds\"], vpdp=self[\"v_1_e_pdp\"])\n            [\n                self._energy_params_dict[\"u_1_0_m_o\"].param,\n                self._energy_params_dict[\"u_1_1_m_o\"].param,\n                self._energy_params_dict[\"u_1_2_m_o\"].param\n            ] = self._h_mx_o(r=-1, vpds=self[\"v_1_o_pds\"], vpdp=self[\"v_1_o_pdp\"])\n            # h2\n            [\n                self._energy_params_dict[\"u_2_0_m_e\"].param,\n                self._energy_params_dict[\"u_2_1_m_e\"].param,\n                self._energy_params_dict[\"u_2_2_m_e\"].param,\n                self._energy_params_dict[\"u_2_3_m_e\"].param,\n                self._energy_params_dict[\"u_2_4_m_e\"].param,\n                self._energy_params_dict[\"u_2_5_m_e\"].param\n            ] = self._h_mm_x_e(vdds=self[\"v_2_e_dds\"], vddp=self[\"v_2_e_ddp\"], vddd=self[\"v_2_e_ddd\"])\n            [\n                self._energy_params_dict[\"u_2_0_m_o\"].param,\n                self._energy_params_dict[\"u_2_1_m_o\"].param,\n                self._energy_params_dict[\"u_2_2_m_o\"].param\n            ] = self._h_mm_x_o(vddp=self[\"v_2_o_ddp\"], vddd=self[\"v_2_o_ddd\"])\n            [\n                self._energy_params_dict[\"u_2_0_x_e\"].param,\n                self._energy_params_dict[\"u_2_1_x_e\"].param,\n                self._energy_params_dict[\"u_2_2_x_e\"].param,\n                self._energy_params_dict[\"u_2_3_x_e\"].param,\n                self._energy_params_dict[\"u_2_4_x_e\"].param,\n                self._energy_params_dict[\"u_2_5_x_e\"].param\n            ] = self._h_xx_x_e(r=np.sqrt(3), vpps=self[\"v_2_e_pps\"], vppp=self[\"v_2_e_ppp\"],\n                               vppstb=self[\"v_2_e_pps_tb\"], vppptb=self[\"v_2_e_ppp_tb\"])\n            [\n                self._energy_params_dict[\"u_2_0_x_o\"].param,\n                self._energy_params_dict[\"u_2_1_x_o\"].param,\n                self._energy_params_dict[\"u_2_2_x_o\"].param,\n                self._energy_params_dict[\"u_2_3_x_o\"].param,\n                self._energy_params_dict[\"u_2_4_x_o\"].param,\n                self._energy_params_dict[\"u_2_5_x_o\"].param\n            ] = self._h_xx_x_o(r=np.sqrt(3), vpps=self[\"v_2_o_pps\"], vppp=self[\"v_2_o_ppp\"],\n                               vppstb=self[\"v_2_o_pps_tb\"], vppptb=self[\"v_2_o_ppp_tb\"])\n            # h3\n            [\n                self._energy_params_dict[\"u_3_0_m_e\"].param,\n                self._energy_params_dict[\"u_3_1_m_e\"].param,\n                self._energy_params_dict[\"u_3_2_m_e\"].param,\n                self._energy_params_dict[\"u_3_3_m_e\"].param,\n                self._energy_params_dict[\"u_3_4_m_e\"].param\n            ] = self._h_mx_e(r=2, vpds=self[\"v_3_e_pds\"], vpdp=self[\"v_3_e_pdp\"])\n            [\n                self._energy_params_dict[\"u_3_0_m_o\"].param,\n                self._energy_params_dict[\"u_3_1_m_o\"].param,\n                self._energy_params_dict[\"u_3_2_m_o\"].param\n            ] = self._h_mx_o(r=2, vpds=self[\"v_3_o_pds\"], vpdp=self[\"v_3_o_pdp\"])\n            # h4\n            [\n                self._energy_params_dict[\"u_4_0_m_e\"].param,\n                self._energy_params_dict[\"u_4_1_m_e\"].param,\n                self._energy_params_dict[\"u_4_2_m_e\"].param,\n                self._energy_params_dict[\"u_4_3_m_e\"].param,\n                self._energy_params_dict[\"u_4_4_m_e\"].param\n            ] = self._h_mx_e(r=-np.sqrt(7), vpds=self[\"v_4_e_pds\"], vpdp=self[\"v_4_e_pdp\"])\n            [\n                self._energy_params_dict[\"u_4_0_m_o\"].param,\n                self._energy_params_dict[\"u_4_1_m_o\"].param,\n                self._energy_params_dict[\"u_4_2_m_o\"].param\n            ] = self._h_mx_o(r=-np.sqrt(7), vpds=self[\"v_4_o_pds\"], vpdp=self[\"v_4_o_pdp\"])\n            # h5\n            [\n                self._energy_params_dict[\"u_5_0_m_e\"].param,\n                self._energy_params_dict[\"u_5_1_m_e\"].param,\n                self._energy_params_dict[\"u_5_3_m_e\"].param,\n                self._energy_params_dict[\"u_5_5_m_e\"].param,\n                self._energy_params_dict[\"u_5_6_m_e\"].param\n            ] = self._h_mm_y_e(vdds=self[\"v_5_e_dds\"], vddp=self[\"v_5_e_ddp\"], vddd=self[\"v_5_e_ddd\"])\n            [\n                self._energy_params_dict[\"u_5_0_m_o\"].param,\n                self._energy_params_dict[\"u_5_2_m_o\"].param\n            ] = self._h_mm_y_o(vddp=self[\"v_5_o_ddp\"], vddd=self[\"v_5_o_ddd\"])\n            [\n                self._energy_params_dict[\"u_5_0_x_e\"].param,\n                self._energy_params_dict[\"u_5_2_x_e\"].param,\n                self._energy_params_dict[\"u_5_3_x_e\"].param,\n                self._energy_params_dict[\"u_5_5_x_e\"].param,\n                self._energy_params_dict[\"u_5_6_x_e\"].param\n            ] = self._h_xx_y_e(r=3, vpps=self[\"v_5_e_pps\"], vppp=self[\"v_5_e_ppp\"],\n                               vppstb=self[\"v_5_e_pps_tb\"], vppptb=self[\"v_5_e_ppp_tb\"])\n            [\n                self._energy_params_dict[\"u_5_0_x_o\"].param,\n                self._energy_params_dict[\"u_5_2_x_o\"].param,\n                self._energy_params_dict[\"u_5_3_x_o\"].param,\n                self._energy_params_dict[\"u_5_5_x_o\"].param,\n                self._energy_params_dict[\"u_5_6_x_o\"].param\n            ] = self._h_xx_y_o(r=3, vpps=self[\"v_5_o_pps\"], vppp=self[\"v_5_o_ppp\"],\n                               vppstb=self[\"v_5_e_pps_tb\"], vppptb=self[\"v_5_o_ppp_tb\"])\n            # h6\n            [\n                self._energy_params_dict[\"u_6_0_m_e\"].param,\n                self._energy_params_dict[\"u_6_1_m_e\"].param,\n                self._energy_params_dict[\"u_6_2_m_e\"].param,\n                self._energy_params_dict[\"u_6_3_m_e\"].param,\n                self._energy_params_dict[\"u_6_4_m_e\"].param,\n                self._energy_params_dict[\"u_6_5_m_e\"].param\n            ] = self._h_mm_x_e(vdds=self[\"v_6_e_dds\"], vddp=self[\"v_6_e_ddp\"], vddd=self[\"v_6_e_ddd\"])\n            [\n                self._energy_params_dict[\"u_6_0_m_o\"].param,\n                self._energy_params_dict[\"u_6_1_m_o\"].param,\n                self._energy_params_dict[\"u_6_2_m_o\"].param\n            ] = self._h_mm_x_o(vddp=self[\"v_6_o_ddp\"], vddd=self[\"v_6_o_ddd\"])\n            [\n                self._energy_params_dict[\"u_6_0_x_e\"].param,\n                self._energy_params_dict[\"u_6_1_x_e\"].param,\n                self._energy_params_dict[\"u_6_2_x_e\"].param,\n                self._energy_params_dict[\"u_6_3_x_e\"].param,\n                self._energy_params_dict[\"u_6_4_x_e\"].param,\n                self._energy_params_dict[\"u_6_5_x_e\"].param\n            ] = self._h_xx_x_e(r=np.sqrt(3), vpps=self[\"v_6_e_pps\"], vppp=self[\"v_6_e_ppp\"],\n                               vppstb=self[\"v_6_e_pps_tb\"], vppptb=self[\"v_6_e_ppp_tb\"])\n            [\n                self._energy_params_dict[\"u_6_0_x_o\"].param,\n                self._energy_params_dict[\"u_6_1_x_o\"].param,\n                self._energy_params_dict[\"u_6_2_x_o\"].param,\n                self._energy_params_dict[\"u_6_3_x_o\"].param,\n                self._energy_params_dict[\"u_6_4_x_o\"].param,\n                self._energy_params_dict[\"u_6_5_x_o\"].param\n            ] = self._h_xx_x_o(r=np.sqrt(3), vpps=self[\"v_6_o_pps\"], vppp=self[\"v_6_o_ppp\"],\n                               vppstb=self[\"v_6_o_pps_tb\"], vppptb=self[\"v_6_o_ppp_tb\"])\n\n    def _subtract_param(self, p1: Optional[float], p2: Optional[float]):\n        return self._comb_nonefloat([p1, -p2 if p2 is not None else None])\n\n    @staticmethod\n    def _h_mm_x_e(vdds: Optional[float], vddp: Optional[float], vddd: Optional[float]) -&gt; List[Optional[float]]:\n        vddsd_bool = (vdds is not None) and (vddd is not None)\n        vddp_bool = vddp is not None\n        u_0: Optional[float] = 1 / 4 * (vdds + 3 * vddd) if vddsd_bool else None\n        u_1: Optional[float] = np.sqrt(3) / 4 * (-vdds + vddd) if vddsd_bool else None\n        u_2: Optional[float] = 0 if (vddsd_bool or vddp_bool) else None\n        u_3: Optional[float] = 1 / 4 * (3 * vdds + vddd) if vddsd_bool else None\n        u_4: Optional[float] = 0 if (vddsd_bool or vddp_bool) else None\n        u_5: Optional[float] = vddp if vddp_bool else None\n        return [u_0, u_1, u_2, u_3, u_4, u_5]\n\n    @staticmethod\n    def _h_mm_y_e(vdds: Optional[float], vddp: Optional[float], vddd: Optional[float]) -&gt; List[Optional[float]]:\n        vddsd_bool = (vdds is not None) and (vddd is not None)\n        vddp_bool = vddp is not None\n        u_0: Optional[float] = 1 / 4 * (vdds + 3 * vddd) if vddsd_bool else None\n        u_1: Optional[float] = np.sqrt(3) / 4 * (-vdds + vddd) if vddsd_bool else None\n        u_3: Optional[float] = 1 / 4 * (3 * vdds + vddd) if vddsd_bool else None\n        u_5: Optional[float] = vddp if vddp_bool else None\n        u_6: Optional[float] = np.sqrt(3) / 4 * (-vdds + vddd) if vddsd_bool else None\n        return [u_0, u_1, u_3, u_5, u_6]\n\n    @staticmethod\n    def _h_mm_x_o(vddp: Optional[float], vddd: Optional[float]) -&gt; List[Optional[float]]:\n        vddd_bool = vddd is not None\n        vddp_bool = vddp is not None\n        u_0: Optional[float] = vddp if vddp_bool else None\n        u_1: Optional[float] = 0 if (vddd_bool or vddp_bool) else None\n        u_2: Optional[float] = vddd if vddd_bool else None\n        return [u_0, u_1, u_2]\n\n    @staticmethod\n    def _h_mm_y_o(vddp: Optional[float], vddd: Optional[float]) -&gt; List[Optional[float]]:\n        vddd_bool = vddd is not None\n        vddp_bool = vddp is not None\n        u_0: Optional[float] = vddp if vddp_bool else None\n        u_2: Optional[float] = vddd if vddd_bool else None\n        return [u_0, u_2]\n\n    @staticmethod\n    def _comb_nonefloat(u_list: List[Optional[float]]) -&gt; Optional[float]:\n        bl = [ul is not None for ul in u_list]\n        return None if np.all(np.logical_not(bl)) else np.sum([u_list[li] for li in np.arange(len(u_list))[bl]])\n\n    def _h_xx_x_e(self, r: float, vpps: Optional[float], vppp: Optional[float],\n                  vppstb: Optional[float] = None, vppptb: Optional[float] = None) -&gt; List[Optional[float]]:\n        vpps_bool = vpps is not None\n        vppp_bool = vppp is not None\n        vptb_bool = vppstb is not None\n        vstb_bool = vppptb is not None\n        u_0_0: Optional[float] = vpps if vpps_bool else None\n        u_0_1: Optional[float] = vppptb if vptb_bool else None\n        u_0_2: Optional[float] = -r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_0: Optional[float] = self._comb_nonefloat([u_0_0, u_0_1, u_0_2])\n        u_1: Optional[float] = 0 if (vpps_bool or vppp_bool or vstb_bool or vptb_bool) else None\n        u_2: Optional[float] = -2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_3_0: Optional[float] = vppp if vppp_bool else None\n        u_3_1: Optional[float] = vppptb if vptb_bool else None\n        u_3: Optional[float] = self._comb_nonefloat([u_3_0, u_3_1])\n        u_4: Optional[float] = 0 if (vpps_bool or vppp_bool or vstb_bool or vptb_bool) else None\n        u_5_0: Optional[float] = vppp if vppp_bool else None\n        u_5_1: Optional[float] = -vppstb if vstb_bool else None\n        u_5_2: Optional[float] = -r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_5: Optional[float] = self._comb_nonefloat([u_5_0, u_5_1, u_5_2])\n        return [u_0, u_1, u_2, u_3, u_4, u_5]\n\n    def _h_xx_y_e(self, r: float, vpps: Optional[float], vppp: Optional[float],\n                  vppstb: Optional[float] = None, vppptb: Optional[float] = None) -&gt; List[Optional[float]]:\n        vpps_bool = vpps is not None\n        vppp_bool = vppp is not None\n        vptb_bool = vppstb is not None\n        vstb_bool = vppptb is not None\n        u_0_0: Optional[float] = vpps if vpps_bool else None\n        u_0_1: Optional[float] = vppptb if vptb_bool else None\n        u_0_2: Optional[float] = -r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_0: Optional[float] = self._comb_nonefloat([u_0_0, u_0_1, u_0_2])\n        u_2: Optional[float] = -2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_3_0: Optional[float] = vppp if vppp_bool else None\n        u_3_1: Optional[float] = vppptb if vptb_bool else None\n        u_3: Optional[float] = self._comb_nonefloat([u_3_0, u_3_1])\n        u_5_0: Optional[float] = vppp if vppp_bool else None\n        u_5_1: Optional[float] = -vppstb if vstb_bool else None\n        u_5_2: Optional[float] = -r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_5: Optional[float] = self._comb_nonefloat([u_5_0, u_5_1, u_5_2])\n        u_6: Optional[float] = 2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        return [u_0, u_2, u_3, u_5, u_6]\n\n    def _h_xx_x_o(self, r: float, vpps: Optional[float], vppp: Optional[float],\n                  vppstb: Optional[float] = None, vppptb: Optional[float] = None) -&gt; List[Optional[float]]:\n        vpps_bool = vpps is not None\n        vppp_bool = vppp is not None\n        vptb_bool = vppstb is not None\n        vstb_bool = vppptb is not None\n        u_0_0: Optional[float] = vpps if vpps_bool else None\n        u_0_1: Optional[float] = -vppptb if vptb_bool else None\n        u_0_2: Optional[float] = r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_0: Optional[float] = self._comb_nonefloat([u_0_0, u_0_1, u_0_2])\n        u_1: Optional[float] = 0 if (vpps_bool or vppp_bool or vstb_bool or vptb_bool) else None\n        u_2: Optional[float] = -2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_3_0: Optional[float] = vppp if vppp_bool else None\n        u_3_1: Optional[float] = -vppptb if vptb_bool else None\n        u_3: Optional[float] = self._comb_nonefloat([u_3_0, u_3_1])\n        u_4: Optional[float] = 0 if (vpps_bool or vppp_bool or vstb_bool or vptb_bool) else None\n        u_5_0: Optional[float] = vppp if vppp_bool else None\n        u_5_1: Optional[float] = vppstb if vstb_bool else None\n        u_5_2: Optional[float] = r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_5: Optional[float] = self._comb_nonefloat([u_5_0, u_5_1, u_5_2])\n        return [u_0, u_1, u_2, u_3, u_4, u_5]\n\n    def _h_xx_y_o(self, r: float, vpps: Optional[float], vppp: Optional[float],\n                  vppstb: Optional[float] = None, vppptb: Optional[float] = None) -&gt; List[Optional[float]]:\n        vpps_bool = vpps is not None\n        vppp_bool = vppp is not None\n        vptb_bool = vppstb is not None\n        vstb_bool = vppptb is not None\n        u_0_0: Optional[float] = vpps if vpps_bool else None\n        u_0_1: Optional[float] = -vppptb if vptb_bool else None\n        u_0_2: Optional[float] = r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_0: Optional[float] = self._comb_nonefloat([u_0_0, u_0_1, u_0_2])\n        u_2: Optional[float] = 2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_3_0: Optional[float] = vppp if vppp_bool else None\n        u_3_1: Optional[float] = -vppptb if vptb_bool else None\n        u_3: Optional[float] = self._comb_nonefloat([u_3_0, u_3_1])\n        u_5_0: Optional[float] = vppp if vppp_bool else None\n        u_5_1: Optional[float] = vppstb if vstb_bool else None\n        u_5_2: Optional[float] = r ** 2 * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        u_5: Optional[float] = self._comb_nonefloat([u_5_0, u_5_1, u_5_2])\n        u_6: Optional[float] = -2 * self._tan_theta * r * (vppptb - vppstb) / (r ** 2 + 4 * self._tan_theta ** 2)\\\n            if vstb_bool and vptb_bool else None\n        return [u_0, u_2, u_3, u_5, u_6]\n\n    def _h_mx_e(self, r: float, vpds: Optional[float], vpdp: Optional[float]) -&gt; List[Optional[float]]:\n        if (vpds is not None) and (vpdp is not None):\n            u_0 = np.sqrt(2) * r * vpdp / (np.sqrt(r ** 2 + self._tan_theta ** 2))\n            u_1 = -r * (\n                    2 * np.sqrt(3) * self._tan_theta ** 2 * vpdp + (r ** 2 - 2 * self._tan_theta ** 2) * vpds\n            ) / (np.sqrt(2) * ((r ** 2 + self._tan_theta ** 2) ** (3 / 2)))\n            u_2 = -r * (\n                    2 * self._tan_theta ** 2 * vpdp + np.sqrt(3) * r ** 2 * vpds\n            ) / (np.sqrt(2) * ((r ** 2 + self._tan_theta ** 2) ** (3 / 2)))\n            u_3 = self._tan_theta * (\n                    r ** 2 * 2 * np.sqrt(3) * vpdp + (2 * self._tan_theta ** 2 - r ** 2) * vpds\n            ) / (np.sqrt(2) * ((r ** 2 + self._tan_theta ** 2) ** (3 / 2)))\n            u_4 = r ** 2 * self._tan_theta * (\n                    2 * vpdp - np.sqrt(3) * vpds\n            ) / (np.sqrt(2) * ((r ** 2 + self._tan_theta ** 2) ** (3 / 2)))\n            return [u_0, u_1, u_2, u_3, u_4]\n        else:\n            return [None, None, None, None, None]\n\n    def _h_mx_o(self, r: float, vpds: Optional[float], vpdp: Optional[float]) -&gt; List[Optional[float]]:\n        if (vpds is not None) and (vpdp is not None):\n            u_0 = np.sqrt(2) * self._tan_theta * vpdp / np.sqrt(r ** 2 + self._tan_theta ** 2)\n            u_1 = np.sqrt(2) * self._tan_theta * (\n                    (self._tan_theta ** 2 - r ** 2) * vpdp + r ** 2 * np.sqrt(3) * vpds\n            ) / ((r ** 2 + self._tan_theta ** 2) ** (3 / 2))\n            u_2 = np.sqrt(2) * r * (\n                    (r ** 2 - self._tan_theta ** 2) * vpdp + self._tan_theta ** 2 * np.sqrt(3) * vpds\n            ) / ((r ** 2 + self._tan_theta ** 2) ** (3 / 2))\n            return [u_0, u_1, u_2]\n        else:\n            return [None, None, None]\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKParametersList.__init__","title":"<code>__init__(input_dict=None)</code>","text":"<p>Initialize the SK parameters</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>The dictionary containing the SK parameters. The keys are the parameter names and the values are the parameter values. The keys are: <code>a</code>, <code>lamb_x</code>, <code>lamb_m</code>, <code>material</code>, <code>theta</code>, <code>delta_p</code>, <code>delta_z</code>, <code>delta_0</code>, <code>delta_1</code>, <code>delta_2</code>, <code>v_0_pps</code>, <code>v_0_ppp</code>, <code>v_1_e_pds</code>, <code>v_1_e_pdp</code>, <code>v_1_o_pds</code>, <code>v_1_o_pdp</code>, <code>v_2_e_pps</code>, <code>v_2_e_ppp</code>, <code>v_2_e_pps_tb</code>, <code>v_2_e_ppp_tb</code>, <code>v_2_o_pps</code>, <code>v_2_o_ppp</code>, <code>v_2_o_pps_tb</code>, <code>v_2_o_ppp_tb</code>, <code>v_2_e_dds</code>, <code>v_2_e_ddp</code>, <code>v_2_e_ddd</code>, <code>v_2_o_ddp</code>, <code>v_2_o_ddd</code>, <code>v_3_e_pds</code>, <code>v_3_e_pdp</code>, <code>v_3_o_pds</code>, <code>v_3_o_pdp</code>, <code>v_4_e_pds</code>, <code>v_4_e_pdp</code>, <code>v_4_o_pds</code>, <code>v_4_o_pdp</code>, <code>v_5_e_pps</code>, <code>v_5_e_ppp</code>, <code>v_5_e_pps_tb</code>, <code>v_5_e_ppp_tb</code>, <code>v_5_o_pps</code>, <code>v_5_o_ppp</code>, <code>v_5_o_pps_tb</code>, <code>v_5_o_ppp_tb</code>, <code>v_5_e_dds</code>, <code>v_5_e_ddp</code>, <code>v_5_e_ddd</code>, <code>v_5_o_ddp</code>, <code>v_5_o_ddd</code>, <code>v_6_e_pps</code>, <code>v_6_e_ppp</code>, <code>v_6_e_pps_tb</code>, <code>v_6_e_ppp_tb</code>, <code>v_6_o_pps</code>, <code>v_6_o_ppp</code>, <code>v_6_o_pps_tb</code>, <code>v_6_o_ppp_tb</code>, <code>v_6_e_dds</code>, <code>v_6_e_ddp</code>, <code>v_6_e_ddd</code>, <code>v_6_o_ddp</code> and <code>v_6_o_ddd</code></p> <code>None</code> Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>def __init__(self, input_dict: Optional[Dict[str, Union[str, Optional[float]]]] = None):\n    \"\"\"Initialize the SK parameters\n\n    Parameters:\n        input_dict (dict): The dictionary containing the SK parameters. The keys are the parameter names and the\n            values are the parameter values. The keys are:\n            `a`, `lamb_x`, `lamb_m`, `material`, `theta`,\n            `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n            `v_0_pps`, `v_0_ppp`,\n            `v_1_e_pds`, `v_1_e_pdp`, `v_1_o_pds`, `v_1_o_pdp`,\n            `v_2_e_pps`, `v_2_e_ppp`, `v_2_e_pps_tb`, `v_2_e_ppp_tb`,\n            `v_2_o_pps`, `v_2_o_ppp`, `v_2_o_pps_tb`, `v_2_o_ppp_tb`,\n            `v_2_e_dds`, `v_2_e_ddp`, `v_2_e_ddd`,\n            `v_2_o_ddp`, `v_2_o_ddd`,\n            `v_3_e_pds`, `v_3_e_pdp`, `v_3_o_pds`, `v_3_o_pdp`,\n            `v_4_e_pds`, `v_4_e_pdp`, `v_4_o_pds`, `v_4_o_pdp`,\n            `v_5_e_pps`, `v_5_e_ppp`, `v_5_e_pps_tb`, `v_5_e_ppp_tb`,\n            `v_5_o_pps`, `v_5_o_ppp`, `v_5_o_pps_tb`, `v_5_o_ppp_tb`,\n            `v_5_e_dds`, `v_5_e_ddp`, `v_5_e_ddd`,\n            `v_5_o_ddp`, `v_5_o_ddd`,\n            `v_6_e_pps`, `v_6_e_ppp`, `v_6_e_pps_tb`, `v_6_e_ppp_tb`,\n            `v_6_o_pps`, `v_6_o_ppp`, `v_6_o_pps_tb`, `v_6_o_ppp_tb`,\n            `v_6_e_dds`, `v_6_e_ddp`, `v_6_e_ddd`,\n            `v_6_o_ddp` and `v_6_o_ddd`\"\"\"\n    super().__init__(None)\n    self._recalculate_params_bool: bool = True\n    self._tan_theta: Optional[float] = None\n\n    onsite_sk_params = [\n        \"theta\",\n        *[f\"delta_{r}\" for r in (\"p\", \"z\", \"0\", \"1\", \"2\")],\n        *[f\"v_0_pp{r}\" for r in (\"s\", \"p\")]\n    ]\n    onsite_sk_params_names = [\n        r\"$\\theta$\",\n        *[rf\"$\\delta_{r}$\" for r in (\"p\", \"z\", \"0\", \"1\", \"2\")],\n        *[rf\"$V^0_{{pp{r}}}$\" for r in (r\"\\sigma\", r\"\\pi\")],\n    ]\n\n    self._onsite_sk_params_dict: dict = dict(zip(\n        onsite_sk_params,\n        [FloatParameter(name=p_name) for p_name in onsite_sk_params_names]\n    ))\n\n    sk_params = [\n        *[f\"v_{n}_{r}_pd{i}\" for n in (\"1\", \"3\", \"4\") for r in (\"e\", \"o\") for i in (\"s\", \"p\")],\n        *[f\"v_{n}_{r}_pp{i}{t}\" for n in (\"2\", \"5\", \"6\")\n          for r in (\"e\", \"o\") for i in (\"s\", \"p\") for t in (\"\", \"_tb\")],\n        *[f\"v_{n}_e_dds\" for n in (\"2\", \"5\", \"6\")],\n        *[f\"v_{n}_{r}_dd{i}\" for n in (\"2\", \"5\", \"6\") for r in (\"e\", \"o\") for i in (\"p\", \"d\")]\n    ]\n\n    sk_params_names = [\n        *[rf\"$V^{{{n}_{r}}}_{{pd{i}}}$\" for n in (\"1\", \"3\", \"4\") for r in (\"e\", \"o\") for i in (r\"\\sigma\", r\"\\pi\")],\n        *[rf\"$V^{{{n}_{r}}}_{{pp{i}{t}}}$\" for n in (\"2\", \"5\", \"6\")\n          for r in (\"e\", \"o\") for i in (r\"\\sigma\", r\"\\pi\") for t in (\"\", \",tb\")],\n        *[rf\"$V^{{{n}_e}}_{{dd\\sigmas}}$\" for n in (\"2\", \"5\", \"6\")],\n        *[rf\"$V^{{{n}_{r}}}_{{dd{i}}}$\" for n in (\"2\", \"5\", \"6\") for r in (\"e\", \"o\") for i in (r\"\\pi\", r\"\\delta\")]\n    ]\n    self._sk_params_dict: dict = dict(zip(\n        sk_params,\n        [FloatParameter(name=p_name) for p_name in sk_params_names]\n    ))\n\n    if input_dict is not None:\n        self.from_dict(input_dict)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKParametersList.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set the value of a parameter and recalculate the parameters.</p> Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"Set the value of a parameter and recalculate the parameters.\"\"\"\n    super().__setitem__(key, value)\n    self._recalculate_params()\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKParametersList.from_dict","title":"<code>from_dict(input_dict)</code>","text":"<p>Set the parameters from a dictionary and recalculate the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>The dictionary containing the SK parameters. The keys are the parameter names and the values are the parameter values. The keys are: <code>a</code>, <code>lamb_x</code>, <code>lamb_m</code>, <code>material</code>, <code>theta</code>, <code>delta_p</code>, <code>delta_z</code>, <code>delta_0</code>, <code>delta_1</code>, <code>delta_2</code>, <code>v_0_pps</code>, <code>v_0_ppp</code>, <code>v_1_e_pds</code>, <code>v_1_e_pdp</code>, <code>v_1_o_pds</code>, <code>v_1_o_pdp</code>, <code>v_2_e_pps</code>, <code>v_2_e_ppp</code>, <code>v_2_e_pps_tb</code>, <code>v_2_e_ppp_tb</code>, <code>v_2_o_pps</code>, <code>v_2_o_ppp</code>, <code>v_2_o_pps_tb</code>, <code>v_2_o_ppp_tb</code>, <code>v_2_e_dds</code>, <code>v_2_e_ddp</code>, <code>v_2_e_ddd</code>, <code>v_2_o_ddp</code>, <code>v_2_o_ddd</code>, <code>v_3_e_pds</code>, <code>v_3_e_pdp</code>, <code>v_3_o_pds</code>, <code>v_3_o_pdp</code>, <code>v_4_e_pds</code>, <code>v_4_e_pdp</code>, <code>v_4_o_pds</code>, <code>v_4_o_pdp</code>, <code>v_5_e_pps</code>, <code>v_5_e_ppp</code>, <code>v_5_e_pps_tb</code>, <code>v_5_e_ppp_tb</code>, <code>v_5_o_pps</code>, <code>v_5_o_ppp</code>, <code>v_5_o_pps_tb</code>, <code>v_5_o_ppp_tb</code>, <code>v_5_e_dds</code>, <code>v_5_e_ddp</code>, <code>v_5_e_ddd</code>, <code>v_5_o_ddp</code>, <code>v_5_o_ddd</code>, <code>v_6_e_pps</code>, <code>v_6_e_ppp</code>, <code>v_6_e_pps_tb</code>, <code>v_6_e_ppp_tb</code>, <code>v_6_o_pps</code>, <code>v_6_o_ppp</code>, <code>v_6_o_pps_tb</code>, <code>v_6_o_ppp_tb</code>, <code>v_6_e_dds</code>, <code>v_6_e_ddp</code>, <code>v_6_e_ddd</code>, <code>v_6_o_ddp</code> and <code>v_6_o_ddd</code></p> required Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>def from_dict(self, input_dict: Dict[str, Union[float, str]]):\n    \"\"\"Set the parameters from a dictionary and recalculate the parameters.\n\n    Parameters:\n        input_dict (dict): The dictionary containing the SK parameters. The keys are the parameter names and the\n            values are the parameter values. The keys are:\n            `a`, `lamb_x`, `lamb_m`, `material`, `theta`,\n            `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n            `v_0_pps`, `v_0_ppp`,\n            `v_1_e_pds`, `v_1_e_pdp`, `v_1_o_pds`, `v_1_o_pdp`,\n            `v_2_e_pps`, `v_2_e_ppp`, `v_2_e_pps_tb`, `v_2_e_ppp_tb`,\n            `v_2_o_pps`, `v_2_o_ppp`, `v_2_o_pps_tb`, `v_2_o_ppp_tb`,\n            `v_2_e_dds`, `v_2_e_ddp`, `v_2_e_ddd`,\n            `v_2_o_ddp`, `v_2_o_ddd`,\n            `v_3_e_pds`, `v_3_e_pdp`, `v_3_o_pds`, `v_3_o_pdp`,\n            `v_4_e_pds`, `v_4_e_pdp`, `v_4_o_pds`, `v_4_o_pdp`,\n            `v_5_e_pps`, `v_5_e_ppp`, `v_5_e_pps_tb`, `v_5_e_ppp_tb`,\n            `v_5_o_pps`, `v_5_o_ppp`, `v_5_o_pps_tb`, `v_5_o_ppp_tb`,\n            `v_5_e_dds`, `v_5_e_ddp`, `v_5_e_ddd`,\n            `v_5_o_ddp`, `v_5_o_ddd`,\n            `v_6_e_pps`, `v_6_e_ppp`, `v_6_e_pps_tb`, `v_6_e_ppp_tb`,\n            `v_6_o_pps`, `v_6_o_ppp`, `v_6_o_pps_tb`, `v_6_o_ppp_tb`,\n            `v_6_e_dds`, `v_6_e_ddp`, `v_6_e_ddd`,\n            `v_6_o_ddp` and `v_6_o_ddd`\"\"\"\n    self._recalculate_params_bool = False\n    super().from_dict(input_dict)\n    self._recalculate_params_bool = True\n    self._recalculate_params()\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKSimpleParametersList","title":"<code>SKSimpleParametersList</code>","text":"<p>               Bases: <code>SKParametersList</code></p> <p>Class to store the simplified SK paramters (no even/odd).</p> Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>class SKSimpleParametersList(SKParametersList):\n    \"\"\"Class to store the simplified SK paramters (no even/odd).\"\"\"\n    def __init__(self, input_dict: Optional[Dict[str, Union[str, Optional[float]]]] = None):\n        \"\"\"Initializes the SKSimpleParametersList object.\n\n        Parameters:\n            input_dict (dict): Dictionary with the SK paramters. The keus are the parameter names and the values are the\n                parameter values. The parameter names are:\n                `a`, `material`, `lamb_x`, `lamb_m`, `theta`,\n                `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n                `v_0_pps`, `v_0_ppp`,\n                `v_1_pds`, `v_1_pdp`,\n                `v_2_dds`, `v_2_ddp`, `v_2_ddd`, `v_2_pps`, `v_2_ppp`, `v_2_pps_tb`, `v_2_ppp_tb`,\n                `v_3_pds`, `v_3_pdp`,\n                `v_4_pds`, `v_4_pdp`,\n                `v_5_dds`, `v_5_ddp`, `v_5_ddd`, `v_5_pps`, `v_5_ppp`, `v_5_pps_tb`, `v_5_ppp_tb`,\n                `v_6_dds`, `v_6_ddp`, `v_6_ddd`, `v_6_pps`, `v_6_ppp`, `v_6_pps_tb` and `v_6_ppp_tb`.\"\"\"\n        super().__init__(None)\n        sk_simple_params = [\n            *[f\"v_{n}_pd{i}\" for n in (\"1\", \"3\", \"4\") for i in (\"s\", \"p\")],\n            *[f\"v_{n}_pp{i}{t}\" for n in (\"2\", \"5\", \"6\") for i in (\"s\", \"p\") for t in (\"\", \"_tb\")],\n            *[f\"v_{n}_dd{i}\" for n in (\"2\", \"5\", \"6\") for i in (\"s\", \"p\", \"d\")]\n        ]\n\n        sk_simple_params_names = [\n            *[rf\"$V^{{{n}}}_{{pd{i}}}$\" for n in (\"1\", \"3\", \"4\") for i in (r\"\\sigma\", r\"\\pi\")],\n            *[rf\"$V^{{{n}}}_{{pp{i}{t}}}$\" for n in (\"2\", \"5\", \"6\") for i in (r\"\\sigma\", r\"\\pi\") for t in (\"\", \",tb\")],\n            *[rf\"$V^{{{n}}}_{{dd{i}}}$\" for n in (\"2\", \"5\", \"6\") for i in (r\"\\sigmas\", r\"\\pi\", r\"\\delta\")]\n        ]\n        self._sk_simple_params_dict: dict = dict(zip(\n            sk_simple_params,\n            [FloatParameter(name=p_name) for p_name in sk_simple_params_names]\n        ))\n\n        if input_dict is not None:\n            self.from_dict(input_dict)\n\n    def _recalculate_params(self):\n        if self._recalculate_params_bool:\n            # h1\n            self._sk_params_dict[\"v_1_e_pds\"].param = self[\"v_1_pds\"]\n            self._sk_params_dict[\"v_1_o_pds\"].param = self[\"v_1_pds\"]\n            self._sk_params_dict[\"v_1_e_pdp\"].param = self[\"v_1_pdp\"]\n            self._sk_params_dict[\"v_1_o_pdp\"].param = self[\"v_1_pdp\"]\n            # h2\n            self._sk_params_dict[\"v_2_e_dds\"].param = self[\"v_2_dds\"]\n            self._sk_params_dict[\"v_2_e_ddp\"].param = self[\"v_2_ddp\"]\n            self._sk_params_dict[\"v_2_o_ddp\"].param = self[\"v_2_ddp\"]\n            self._sk_params_dict[\"v_2_e_ddd\"].param = self[\"v_2_ddd\"]\n            self._sk_params_dict[\"v_2_o_ddd\"].param = self[\"v_2_ddd\"]\n            self._sk_params_dict[\"v_2_e_pps\"].param = self[\"v_2_pps\"]\n            self._sk_params_dict[\"v_2_o_pps\"].param = self[\"v_2_pps\"]\n            self._sk_params_dict[\"v_2_e_ppp\"].param = self[\"v_2_ppp\"]\n            self._sk_params_dict[\"v_2_o_ppp\"].param = self[\"v_2_ppp\"]\n            self._sk_params_dict[\"v_2_e_pps_tb\"].param = self[\"v_2_pps_tb\"]\n            self._sk_params_dict[\"v_2_o_pps_tb\"].param = self[\"v_2_pps_tb\"]\n            self._sk_params_dict[\"v_2_e_ppp_tb\"].param = self[\"v_2_ppp_tb\"]\n            self._sk_params_dict[\"v_2_o_ppp_tb\"].param = self[\"v_2_ppp_tb\"]\n            # h3\n            self._sk_params_dict[\"v_3_e_pds\"].param = self[\"v_3_pds\"]\n            self._sk_params_dict[\"v_3_o_pds\"].param = self[\"v_3_pds\"]\n            self._sk_params_dict[\"v_3_e_pdp\"].param = self[\"v_3_pdp\"]\n            self._sk_params_dict[\"v_3_o_pdp\"].param = self[\"v_3_pdp\"]\n            # h4\n            self._sk_params_dict[\"v_4_e_pds\"].param = self[\"v_4_pds\"]\n            self._sk_params_dict[\"v_4_o_pds\"].param = self[\"v_4_pds\"]\n            self._sk_params_dict[\"v_4_e_pdp\"].param = self[\"v_4_pdp\"]\n            self._sk_params_dict[\"v_4_o_pdp\"].param = self[\"v_4_pdp\"]\n            # h5\n            self._sk_params_dict[\"v_5_e_dds\"].param = self[\"v_5_dds\"]\n            self._sk_params_dict[\"v_5_e_ddp\"].param = self[\"v_5_ddp\"]\n            self._sk_params_dict[\"v_5_o_ddp\"].param = self[\"v_5_ddp\"]\n            self._sk_params_dict[\"v_5_e_ddd\"].param = self[\"v_5_ddd\"]\n            self._sk_params_dict[\"v_5_o_ddd\"].param = self[\"v_5_ddd\"]\n            self._sk_params_dict[\"v_5_e_pps\"].param = self[\"v_5_pps\"]\n            self._sk_params_dict[\"v_5_o_pps\"].param = self[\"v_5_pps\"]\n            self._sk_params_dict[\"v_5_e_ppp\"].param = self[\"v_5_ppp\"]\n            self._sk_params_dict[\"v_5_o_ppp\"].param = self[\"v_5_ppp\"]\n            self._sk_params_dict[\"v_5_e_pps_tb\"].param = self[\"v_5_pps_tb\"]\n            self._sk_params_dict[\"v_5_o_pps_tb\"].param = self[\"v_5_pps_tb\"]\n            self._sk_params_dict[\"v_5_e_ppp_tb\"].param = self[\"v_5_ppp_tb\"]\n            self._sk_params_dict[\"v_5_o_ppp_tb\"].param = self[\"v_5_ppp_tb\"]\n            # h6\n            self._sk_params_dict[\"v_6_e_dds\"].param = self[\"v_6_dds\"]\n            self._sk_params_dict[\"v_6_e_ddp\"].param = self[\"v_6_ddp\"]\n            self._sk_params_dict[\"v_6_o_ddp\"].param = self[\"v_6_ddp\"]\n            self._sk_params_dict[\"v_6_e_ddd\"].param = self[\"v_6_ddd\"]\n            self._sk_params_dict[\"v_6_o_ddd\"].param = self[\"v_6_ddd\"]\n            self._sk_params_dict[\"v_6_e_pps\"].param = self[\"v_6_pps\"]\n            self._sk_params_dict[\"v_6_o_pps\"].param = self[\"v_6_pps\"]\n            self._sk_params_dict[\"v_6_e_ppp\"].param = self[\"v_6_ppp\"]\n            self._sk_params_dict[\"v_6_o_ppp\"].param = self[\"v_6_ppp\"]\n            self._sk_params_dict[\"v_6_e_pps_tb\"].param = self[\"v_6_pps_tb\"]\n            self._sk_params_dict[\"v_6_o_pps_tb\"].param = self[\"v_6_pps_tb\"]\n            self._sk_params_dict[\"v_6_e_ppp_tb\"].param = self[\"v_6_ppp_tb\"]\n            self._sk_params_dict[\"v_6_o_ppp_tb\"].param = self[\"v_6_ppp_tb\"]\n            super()._recalculate_params()\n\n    @property\n    def _unique_params_dict(self) -&gt; List[dict]:\n        return [self._general_params_dict, self._onsite_sk_params_dict, self._sk_simple_params_dict]\n\n    @property\n    def _protected_params_dict(self) -&gt; Optional[List[dict]]:\n        return [self._sk_params_dict, self._energy_params_dict]\n</code></pre>"},{"location":"documentation/api/#tmdybinding.SKSimpleParametersList.__init__","title":"<code>__init__(input_dict=None)</code>","text":"<p>Initializes the SKSimpleParametersList object.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>Dictionary with the SK paramters. The keus are the parameter names and the values are the parameter values. The parameter names are: <code>a</code>, <code>material</code>, <code>lamb_x</code>, <code>lamb_m</code>, <code>theta</code>, <code>delta_p</code>, <code>delta_z</code>, <code>delta_0</code>, <code>delta_1</code>, <code>delta_2</code>, <code>v_0_pps</code>, <code>v_0_ppp</code>, <code>v_1_pds</code>, <code>v_1_pdp</code>, <code>v_2_dds</code>, <code>v_2_ddp</code>, <code>v_2_ddd</code>, <code>v_2_pps</code>, <code>v_2_ppp</code>, <code>v_2_pps_tb</code>, <code>v_2_ppp_tb</code>, <code>v_3_pds</code>, <code>v_3_pdp</code>, <code>v_4_pds</code>, <code>v_4_pdp</code>, <code>v_5_dds</code>, <code>v_5_ddp</code>, <code>v_5_ddd</code>, <code>v_5_pps</code>, <code>v_5_ppp</code>, <code>v_5_pps_tb</code>, <code>v_5_ppp_tb</code>, <code>v_6_dds</code>, <code>v_6_ddp</code>, <code>v_6_ddd</code>, <code>v_6_pps</code>, <code>v_6_ppp</code>, <code>v_6_pps_tb</code> and <code>v_6_ppp_tb</code>.</p> <code>None</code> Source code in <code>tmdybinding/parameters/slater_koster.py</code> <pre><code>def __init__(self, input_dict: Optional[Dict[str, Union[str, Optional[float]]]] = None):\n    \"\"\"Initializes the SKSimpleParametersList object.\n\n    Parameters:\n        input_dict (dict): Dictionary with the SK paramters. The keus are the parameter names and the values are the\n            parameter values. The parameter names are:\n            `a`, `material`, `lamb_x`, `lamb_m`, `theta`,\n            `delta_p`, `delta_z`, `delta_0`, `delta_1`, `delta_2`,\n            `v_0_pps`, `v_0_ppp`,\n            `v_1_pds`, `v_1_pdp`,\n            `v_2_dds`, `v_2_ddp`, `v_2_ddd`, `v_2_pps`, `v_2_ppp`, `v_2_pps_tb`, `v_2_ppp_tb`,\n            `v_3_pds`, `v_3_pdp`,\n            `v_4_pds`, `v_4_pdp`,\n            `v_5_dds`, `v_5_ddp`, `v_5_ddd`, `v_5_pps`, `v_5_ppp`, `v_5_pps_tb`, `v_5_ppp_tb`,\n            `v_6_dds`, `v_6_ddp`, `v_6_ddd`, `v_6_pps`, `v_6_ppp`, `v_6_pps_tb` and `v_6_ppp_tb`.\"\"\"\n    super().__init__(None)\n    sk_simple_params = [\n        *[f\"v_{n}_pd{i}\" for n in (\"1\", \"3\", \"4\") for i in (\"s\", \"p\")],\n        *[f\"v_{n}_pp{i}{t}\" for n in (\"2\", \"5\", \"6\") for i in (\"s\", \"p\") for t in (\"\", \"_tb\")],\n        *[f\"v_{n}_dd{i}\" for n in (\"2\", \"5\", \"6\") for i in (\"s\", \"p\", \"d\")]\n    ]\n\n    sk_simple_params_names = [\n        *[rf\"$V^{{{n}}}_{{pd{i}}}$\" for n in (\"1\", \"3\", \"4\") for i in (r\"\\sigma\", r\"\\pi\")],\n        *[rf\"$V^{{{n}}}_{{pp{i}{t}}}$\" for n in (\"2\", \"5\", \"6\") for i in (r\"\\sigma\", r\"\\pi\") for t in (\"\", \",tb\")],\n        *[rf\"$V^{{{n}}}_{{dd{i}}}$\" for n in (\"2\", \"5\", \"6\") for i in (r\"\\sigmas\", r\"\\pi\", r\"\\delta\")]\n    ]\n    self._sk_simple_params_dict: dict = dict(zip(\n        sk_simple_params,\n        [FloatParameter(name=p_name) for p_name in sk_simple_params_names]\n    ))\n\n    if input_dict is not None:\n        self.from_dict(input_dict)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.StrainParametersList","title":"<code>StrainParametersList</code>","text":"<p>               Bases: <code>ParametersList</code></p> <p>List of strain parameters.</p> Source code in <code>tmdybinding/parameters/strain.py</code> <pre><code>class StrainParametersList(ParametersList):\n    \"\"\"List of strain parameters.\"\"\"\n\n    def __init__(self, input_dict: Optional[Dict[str, Union[float, List[float]]]] = None, max_order: int = 1):\n        super().__init__(None)\n        self.max_order = max_order\n        strain_params = []\n        strain_params_names = []\n\n        # biaxial and uniaxial strain parameters\n        for strain_type in (\"b\", \"u\", \"s\"):\n            for order_idx in range(1, self.max_order+1):\n                strain_part = f\"{strain_type}_{str(order_idx)}\"\n                strain_part_name = rf\"{strain_type},{str(order_idx)}\"\n                if not strain_type == \"s\":\n                    for param_key, param_float in self._energy_params_dict.items():\n                        strain_params.append(rf\"{param_key}_{strain_part}\")\n                        check_for = r\"$\\epsilon_\" if \"eps_\" in param_key else r\"$u_\"\n                        split_idx, split_len = len(check_for), 1\n                        param_name = param_float.name\n                        pre_name = param_name[:split_idx]\n                        idx_name = param_name[split_idx:split_idx+split_len]\n                        pst_name = param_name[split_idx+split_len:]\n                        assert pre_name == check_for, f\"Expected {check_for}, got {pre_name}\"\n                        strain_params_names.append(rf\"{pre_name}{{{idx_name},{strain_part_name}}}{pst_name}\")\n                else:\n                    params_shear = [\n                        *[f\"u_{u}_{i}_m_e_{strain_part}\" for u in (\"1\", \"3\", \"4\") for i in range(5, 9)],\n                        *[f\"u_{u}_{i}_m_o_{strain_part}\" for u in (\"1\", \"3\", \"4\") for i in range(3, 6)],\n                        *[f\"u_{u}_{i}_{m}_e_{strain_part}\" for u in (\"2\", \"6\") for i in (\"1\", \"2\", \"4\") for m in (\"m\", \"x\")],\n                        *[f\"u_{u}_{i}_x_o_{strain_part}\" for u in (\"2\", \"6\") for i in (\"1\", \"2\", \"4\")],\n                        *[f\"u_{u}_{i}_m_o_{strain_part}\" for u in (\"2\", \"6\") for i in range(1)],\n                        *[f\"u_{u}_{i}_m_e_{strain_part}\" for u in \"5\" for i in (\"2\", \"4\", \"7\", \"8\")],\n                        *[f\"u_{u}_{i}_x_{r}_{strain_part}\" for u in \"5\" for i in (\"1\", \"4\", \"7\", \"8\") for r in (\"e\", \"o\")],\n                        *[f\"u_{u}_{i}_m_o_{strain_part}\" for u in \"5\" for i in (\"1\", \"3\")],\n                    ]\n                    params_names_shear = [\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},e}}$\" for u in (\"1\", \"3\", \"4\") for i in range(5, 9)],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},o}}$\" for u in (\"1\", \"3\", \"4\") for i in range(3, 6)],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},{m}e}}$\" for u in (\"2\", \"6\") for i in (\"1\", \"2\", \"4\") for m in (\"M\", \"X\")],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},Xo}}$\" for u in (\"2\", \"6\") for i in (\"1\", \"2\", \"4\")],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},Mo}}$\" for u in (\"2\", \"6\") for i in range(1)],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},Me}}$\" for u in \"5\" for i in (\"2\", \"4\", \"7\", \"8\")],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},X{r}}}$\" for u in \"5\" for i in (\"2\", \"4\", \"7\", \"8\") for r in (\"e\", \"o\")],\n                        *[rf\"$u_{{{u},{strain_part_name}}}^{{{i},Mo}}$\" for u in \"5\" for i in (\"1\", \"3\")],\n                    ]\n                    strain_params.extend(params_shear)\n                    strain_params_names.extend(params_names_shear)\n\n\n        # shear strain parameters, only hoppings as onsite are given by the uniaxial parameters\n        self._strain_params_dict: dict = dict(zip(\n            strain_params,\n            [FloatParameter(name=p_name) for p_name in strain_params_names]\n        ))\n\n\n        if input_dict is not None:\n            self.from_dict(input_dict)\n\n    @property\n    def _unique_params_dict(self) -&gt; List[dict]:\n        return [self._general_params_dict, self._energy_params_dict, self._strain_params_dict]\n</code></pre>"},{"location":"documentation/api/#tmdybinding.StringParameter","title":"<code>StringParameter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Class to store one separate string parameter</p> Source code in <code>tmdybinding/parameters/symmetry_group.py</code> <pre><code>@dataclass\nclass StringParameter(Parameter):\n    \"\"\"Class to store one separate string parameter\"\"\"\n    param: Optional[str] = None\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdMatrices","title":"<code>TmdMatrices</code>","text":"<p>Construct the TMD hopping matrices</p> Source code in <code>tmdybinding/tmd_hopping_matrices.py</code> <pre><code>class TmdMatrices:\n    \"\"\"Construct the TMD hopping matrices\"\"\"\n    def __init__(self, params: ParametersList):\n        \"\"\"Initialize the TMD hopping matrices\n\n        Parameters:\n            params (ParametersList): The parameters for the TMD lattice.\"\"\"\n        self.params = params\n\n    @staticmethod\n    def _t_n_e(u_0, u_1, u_2, u_3, u_4) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the first-, third- and fourth-nearest neighbours from the even metal orbitals\"\"\"\n        return np.array([[0, 0, u_0], [u_1, u_2, 0], [u_3, u_4, 0]])\n\n    @staticmethod\n    def _t_n_o(u_0, u_1, u_2) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the first-, third- and fourth-nearest neighbours from the odd metal orbitals\"\"\"\n        return np.array([[u_0, 0], [0, u_1], [0, u_2]])\n\n    @staticmethod\n    def _t_m_xr(u_0, u_1, u_2, u_3, u_4, u_5) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second- and sixth-nearest neighbours from the chalcogen orbitals\"\"\"\n        return np.array([[u_0, u_1, u_2], [-u_1, u_3, u_4], [-u_2, u_4, u_5]])\n\n    @staticmethod\n    def _t_m_me(u_0, u_1, u_2, u_3, u_4, u_5) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second-, fifth- and sixth-nearest neighbours from the even metal orbitals\"\"\"\n        return np.array([[u_0, u_1, u_2], [u_1, u_3, u_4], [-u_2, -u_4, u_5]])\n\n    @staticmethod\n    def _t_m_mo(u_0, u_1, u_2) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second-, fifth- and sixth-nearest neighbours from the odd metal orbitals\"\"\"\n        return np.array([[u_0, u_1], [-u_1, u_2]])\n\n    @staticmethod\n    def _t_5_me(u_0, u_1, u_3, u_5, u_6) -&gt;np.ndarray:\n        \"\"\"The hopping matrix for the fifth-nearest neighbours from the even metal orbitals\"\"\"\n        return np.array([[u_0, -u_1, 0.0], [-u_6, u_3, 0.0], [0.0, 0.0, u_5]])\n\n    @staticmethod\n    def _t_5_mo(u_0, u_2) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the fifth-nearest neighbours from the odd metal orbitals\"\"\"\n        return np.diag((u_2, u_0))\n\n    @staticmethod\n    def _t_5_xr(u_0, u_2, u_3, u_5, u_6) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the fifth-nearest neighbours from the chalcogen orbitals\"\"\"\n        return np.array([[u_3, 0, 0], [0, u_0, u_2], [0, u_6, u_5]])\n\n    @property\n    def e_xe(self) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the even chalcogen orbitals\"\"\"\n        return np.diag((self.params[\"eps_0_x_e\"], self.params[\"eps_0_x_e\"], self.params[\"eps_1_x_e\"]))\n\n    @property\n    def e_xo(self) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the odd chalcogen orbitals\"\"\"\n        return np.diag((self.params[\"eps_0_x_o\"], self.params[\"eps_0_x_o\"], self.params[\"eps_1_x_o\"]))\n\n    @property\n    def e_me(self) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the even metal orbitals\"\"\"\n        return np.diag((self.params[\"eps_0_m_e\"], self.params[\"eps_1_m_e\"], self.params[\"eps_1_m_e\"]))\n\n    @property\n    def e_mo(self) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the odd metal orbitals\"\"\"\n        return np.diag((self.params[\"eps_0_m_o\"], self.params[\"eps_0_m_o\"]))\n\n    @property\n    def t_1_me(self) -&gt; np.ndarray:\n        \"\"\"The first-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_n_e(*[self.params[f\"u_1_{i}_m_e\"] for i in range(5)])\n\n    @property\n    def t_1_mo(self) -&gt; np.ndarray:\n        \"\"\"The first-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_n_o(*[self.params[f\"u_1_{i}_m_o\"] for i in range(3)])\n\n    @property\n    def t_2_me(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_m_me(*[self.params[f\"u_2_{i}_m_e\"] for i in range(6)])\n\n    @property\n    def t_2_mo(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_m_mo(*[self.params[f\"u_2_{i}_m_o\"] for i in range(3)])\n\n    @property\n    def t_2_xe(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping matrix from the even chalcogen orbitals\"\"\"\n        return self._t_m_xr(*[self.params[f\"u_2_{i}_x_e\"] for i in range(6)])\n\n    @property\n    def t_2_xo(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd chalcogen orbitals\"\"\"\n        return self._t_m_xr(*[self.params[f\"u_2_{i}_x_o\"] for i in range(6)])\n\n    @property\n    def t_3_me(self) -&gt; np.ndarray:\n        \"\"\"The third-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_n_e(*[self.params[f\"u_3_{i}_m_e\"] for i in range(5)])\n\n    @property\n    def t_3_mo(self) -&gt; np.ndarray:\n        \"\"\"The third-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_n_o(*[self.params[f\"u_3_{i}_m_o\"] for i in range(3)])\n\n    @property\n    def t_4_me(self) -&gt; np.ndarray:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_n_e(*[self.params[f\"u_4_{i}_m_e\"] for i in range(5)])\n\n    @property\n    def t_4_mo(self) -&gt; np.ndarray:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_n_o(*[self.params[f\"u_4_{i}_m_o\"] for i in range(3)])\n\n    @property\n    def t_5_me(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_5_me(*[self.params[f\"u_5_{i}_m_e\"] for i in (\"0\", \"1\", \"3\", \"5\", \"6\")])\n\n    @property\n    def t_5_mo(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_5_mo(*[self.params[f\"u_5_{i}_m_o\"] for i in (\"0\", \"2\")])\n\n    @property\n    def t_5_xe(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals\"\"\"\n        return self._t_5_xr(*[self.params[f\"u_5_{i}_x_e\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n\n    @property\n    def t_5_xo(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals\"\"\"\n        return self._t_5_xr(*[self.params[f\"u_5_{i}_x_o\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n\n    @property\n    def t_6_me(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even metal orbitals\"\"\"\n        return self._t_m_me(*[self.params[f\"u_6_{i}_m_e\"] for i in range(6)])\n\n    @property\n    def t_6_mo(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd metal orbitals\"\"\"\n        return self._t_m_mo(*[self.params[f\"u_6_{i}_m_o\"] for i in range(3)])\n\n    @property\n    def t_6_xe(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals\"\"\"\n        return self._t_m_xr(*[self.params[f\"u_6_{i}_x_e\"] for i in range(6)])\n\n    @property\n    def t_6_xo(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals\"\"\"\n        return self._t_m_xr(*[self.params[f\"u_6_{i}_x_o\"] for i in range(6)])\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.e_me","title":"<code>e_me: np.ndarray</code>  <code>property</code>","text":"<p>The hopping matrix for the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.e_mo","title":"<code>e_mo: np.ndarray</code>  <code>property</code>","text":"<p>The hopping matrix for the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.e_xe","title":"<code>e_xe: np.ndarray</code>  <code>property</code>","text":"<p>The hopping matrix for the even chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.e_xo","title":"<code>e_xo: np.ndarray</code>  <code>property</code>","text":"<p>The hopping matrix for the odd chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_1_me","title":"<code>t_1_me: np.ndarray</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_1_mo","title":"<code>t_1_mo: np.ndarray</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_2_me","title":"<code>t_2_me: np.ndarray</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_2_mo","title":"<code>t_2_mo: np.ndarray</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_2_xe","title":"<code>t_2_xe: np.ndarray</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_2_xo","title":"<code>t_2_xo: np.ndarray</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_3_me","title":"<code>t_3_me: np.ndarray</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_3_mo","title":"<code>t_3_mo: np.ndarray</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_4_me","title":"<code>t_4_me: np.ndarray</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_4_mo","title":"<code>t_4_mo: np.ndarray</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_5_me","title":"<code>t_5_me: np.ndarray</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_5_mo","title":"<code>t_5_mo: np.ndarray</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_5_xe","title":"<code>t_5_xe: np.ndarray</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_5_xo","title":"<code>t_5_xo: np.ndarray</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_6_me","title":"<code>t_6_me: np.ndarray</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_6_mo","title":"<code>t_6_mo: np.ndarray</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd metal orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_6_xe","title":"<code>t_6_xe: np.ndarray</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.t_6_xo","title":"<code>t_6_xo: np.ndarray</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals</p>"},{"location":"documentation/api/#tmdybinding.TmdMatrices.__init__","title":"<code>__init__(params)</code>","text":"<p>Initialize the TMD hopping matrices</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ParametersList</code> <p>The parameters for the TMD lattice.</p> required Source code in <code>tmdybinding/tmd_hopping_matrices.py</code> <pre><code>def __init__(self, params: ParametersList):\n    \"\"\"Initialize the TMD hopping matrices\n\n    Parameters:\n        params (ParametersList): The parameters for the TMD lattice.\"\"\"\n    self.params = params\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN123456MeoXeo","title":"<code>TmdNN123456MeoXeo</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>11 bands model for metal and chalcogen orbitals with all the hoppings up to sixth nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN123456MeoXeo(AbstractLattice):\n    \"\"\"11 bands model for metal and chalcogen orbitals with all the hoppings up to sixth nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2, 1, -1], \"X\": [1, -1, 0, 1, -1, 0]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\", \"dxz\", \"dyz\"], \"X\": [\"pxe\", \"pye\", \"pze\", \"pxo\", \"pyo\", \"pzo\"]},\n            group={\"M\": [0, 1, 1, 2, 2], \"X\": [0, 0, 1, 2, 2, 3]}\n        )\n        super().__init__(orbital=orbital, params=all[\"MoS2\"], lattice_name=\"11 bands 6NN model\",\n                         n_v=6, n_b=11)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = self.block_diag(t_m.e_me, t_m.e_mo)\n        h_0_x = self.block_diag(t_m.e_xe, t_m.e_xo)\n        h_1_m = self.block_diag(t_m.t_1_me, t_m.t_1_mo)\n        h_2_m = self.block_diag(t_m.t_2_me, t_m.t_2_mo)\n        h_2_x = self.block_diag(t_m.t_2_xe, t_m.t_2_xo)\n        h_3_m = self.block_diag(t_m.t_3_me, t_m.t_3_mo)\n        h_4_m = self.block_diag(t_m.t_4_me, t_m.t_4_mo)\n        h_5_m = self.block_diag(t_m.t_5_me, t_m.t_5_mo)\n        h_5_x = self.block_diag(t_m.t_5_xe, t_m.t_5_xo)\n        h_6_m = self.block_diag(t_m.t_6_me, t_m.t_6_mo)\n        h_6_x = self.block_diag(t_m.t_6_xe, t_m.t_6_xo)\n        keys = [\"h_0_m\", \"h_0_c\", \"h_1_m\", \"h_2_m\", \"h_2_c\", \"h_3_m\", \"h_4_m\", \"h_5_m\", \"h_5_c\", \"h_6_m\", \"h_6_c\",\n                \"a\", \"lamb_m\", \"lamb_c\"]\n        values = [h_0_m, h_0_x, h_1_m, h_2_m, h_2_x, h_3_m, h_4_m, h_5_m, h_5_x, h_6_m, h_6_x,\n                  self.params[\"a\"], self.params[\"lamb_m\"], self.params[\"lamb_x\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN123MeoXeo","title":"<code>TmdNN123MeoXeo</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>11 bands model for metal and chalcogen orbitals with the first-, second- and third-nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN123MeoXeo(AbstractLattice):\n    \"\"\"11 bands model for metal and chalcogen orbitals with the first-, second- and third-nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2, 1, -1], \"X\": [1, -1, 0, 1, -1, 0]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\", \"dxz\", \"dyz\"], \"X\": [\"pxe\", \"pye\", \"pze\", \"pxo\", \"pyo\", \"pzo\"]},\n            group={\"M\": [0, 1, 1, 2, 2], \"X\": [0, 0, 1, 2, 2, 3]}\n        )\n        super().__init__(orbital=orbital, params=fang[\"MoS2\"], lattice_name=\"11 bands 3NN model\",\n                         n_v=6, n_b=11)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = self.block_diag(t_m.e_me, t_m.e_mo)\n        h_0_x = self.block_diag(t_m.e_xe, t_m.e_xo)\n        h_1_m = self.block_diag(t_m.t_1_me, t_m.t_1_mo)\n        h_2_m = self.block_diag(t_m.t_2_me, t_m.t_2_mo)\n        h_2_x = self.block_diag(t_m.t_2_xe, t_m.t_2_xo)\n        h_3_m = self.block_diag(t_m.t_3_me, t_m.t_1_mo * 0)\n        keys = [\"h_0_m\", \"h_0_c\", \"h_1_m\", \"h_2_m\", \"h_2_c\", \"h_3_m\",\n                \"a\", \"lamb_m\", \"lamb_c\"]\n        values = [h_0_m, h_0_x, h_1_m, h_2_m, h_2_x, h_3_m,\n                  self.params[\"a\"], self.params[\"lamb_m\"], self.params[\"lamb_x\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN125MeoXeo","title":"<code>TmdNN125MeoXeo</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>11 bands model for metal and chalcogen orbitals with the first-, second- and fifth- nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN125MeoXeo(AbstractLattice):\n    \"\"\"11 bands model for metal and chalcogen orbitals with the first-, second- and fifth- nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2, 1, -1], \"X\": [1, -1, 0, 1, -1, 0]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\", \"dxz\", \"dyz\"], \"X\": [\"pxe\", \"pye\", \"pze\", \"pxo\", \"pyo\", \"pzo\"]},\n            group={\"M\": [0, 1, 1, 2, 2], \"X\": [0, 0, 1, 2, 2, 3]}\n        )\n        super().__init__(orbital=orbital, params=dias[\"MoS2\"], lattice_name=\"11 bands 5NN model\",\n                         n_v=6, n_b=11)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = self.block_diag(t_m.e_me, t_m.e_mo)\n        h_0_x = self.block_diag(t_m.e_xe, t_m.e_xo)\n        h_1_m = self.block_diag(t_m.t_1_me, t_m.t_1_mo)\n        h_2_m = self.block_diag(t_m.t_2_me, t_m.t_2_mo)\n        h_2_x = self.block_diag(t_m.t_2_xe, t_m.t_2_xo)\n        h_5_m = self.block_diag(t_m.t_5_me, t_m.t_5_mo)\n        h_5_x = self.block_diag(t_m.t_5_xe, t_m.t_5_xo)\n        keys = [\"h_0_m\", \"h_0_c\", \"h_1_m\", \"h_2_m\", \"h_2_c\", \"h_5_m\", \"h_5_c\",\n                \"a\", \"lamb_m\", \"lamb_c\"]\n        values = [h_0_m, h_0_x, h_1_m, h_2_m, h_2_x, h_5_m, h_5_x,\n                  self.params[\"a\"], self.params[\"lamb_m\"], self.params[\"lamb_x\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN12MeXe","title":"<code>TmdNN12MeXe</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>6 bands model for even metal and chalcogen orbitals with the first- and second-nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN12MeXe(AbstractLattice):\n    \"\"\"6 bands model for even metal and chalcogen orbitals with the first- and second-nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2], \"X\": [1, -1, 0]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\"], \"X\": [\"pxe\", \"pye\", \"pze\"]},\n            group={\"M\": [0, 2, 2], \"X\": [0, 0, 1]}\n        )\n        super().__init__(orbital=orbital, params=jorissen[\"MoS2\"], lattice_name=\"6 bands 2NN model\",\n                         n_v=3, n_b=6)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = t_m.e_me\n        h_0_x = t_m.e_xe\n        h_1_m = t_m.t_1_me\n        h_2_m = t_m.t_2_me\n        h_2_x = t_m.t_2_xe\n        keys = [\"h_0_m\", \"h_0_c\", \"h_1_m\", \"h_2_m\", \"h_2_c\", \"a\", \"lamb_m\", \"lamb_c\"]\n        values = [h_0_m, h_0_x, h_1_m, h_2_m, h_2_x, self.params[\"a\"], self.params[\"lamb_m\"], self.params[\"lamb_x\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN12MeoXeo","title":"<code>TmdNN12MeoXeo</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>3 bands model for metal and chalocogen orbitals with the first- and second-nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN12MeoXeo(AbstractLattice):\n    \"\"\"3 bands model for metal and chalocogen orbitals with the first- and second-nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2, 1, -1], \"X\": [1, -1, 0, 1, -1, 0]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\", \"dxz\", \"dyz\"], \"X\": [\"pxe\", \"pye\", \"pze\", \"pxo\", \"pyo\", \"pzo\"]},\n            group={\"M\": [0, 1, 1, 2, 2], \"X\": [0, 0, 1, 2, 2, 3]}\n        )\n        super().__init__(orbital=orbital, params=cappelluti[\"MoS2\"], lattice_name=\"11 bands 2NN model\",\n                         n_v=6, n_b=11)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = self.block_diag(t_m.e_me, t_m.e_mo)\n        h_0_x = self.block_diag(t_m.e_xe, t_m.e_xo)\n        h_1_m = self.block_diag(t_m.t_1_me, t_m.t_1_mo)\n        h_2_m = self.block_diag(t_m.t_2_me, t_m.t_2_mo)\n        h_2_x = self.block_diag(t_m.t_2_xe, t_m.t_2_xo)\n        keys = [\"h_0_m\", \"h_0_c\", \"h_1_m\", \"h_2_m\", \"h_2_c\", \"a\", \"lamb_m\", \"lamb_c\"]\n        values = [h_0_m, h_0_x, h_1_m, h_2_m, h_2_x, self.params[\"a\"], self.params[\"lamb_m\"], self.params[\"lamb_x\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN256Me","title":"<code>TmdNN256Me</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>3 bands model for even metal orbitals with the second-, fifth- and sixth-nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN256Me(AbstractLattice):\n    \"\"\"3 bands model for even metal orbitals with the second-, fifth- and sixth-nearest-neighbor hopping\"\"\"\n\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\"]},\n            group={\"M\": [0, 1, 1]}\n        )\n        super().__init__(orbital=orbital, params=liu6[\"MoS2\"], lattice_name=\"3 bands 6NN model\",\n                         n_v=0, n_b=3)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = t_m.e_me\n        h_2_m = t_m.t_2_me\n        h_5_m = t_m.t_5_me\n        h_6_m = t_m.t_6_me\n        keys = [\"h_0_m\", \"h_2_m\", \"h_5_m\", \"h_6_m\", \"a\", \"lamb_m\"]\n        values = [h_0_m, h_2_m, h_5_m, h_6_m, self.params[\"a\"], self.params[\"lamb_m\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN256Meo","title":"<code>TmdNN256Meo</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>5 bands model for metal orbitals with the second-, fifth- and sixth-nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN256Meo(AbstractLattice):\n    \"\"\"5 bands model for metal orbitals with the second-, fifth- and sixth-nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2, 1, -1]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\", \"dxz\", \"dyz\"]},\n            group={\"M\": [0, 1, 1, 2, 2]}\n        )\n        super().__init__(orbital=orbital, params=wu[\"MoS2\"], lattice_name=\"5 bands 6NN model\",\n                         n_v=0, n_b=5)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = self.block_diag(t_m.e_me, t_m.e_mo)\n        h_2_m = self.block_diag(t_m.t_2_me, t_m.t_2_mo)\n        h_5_m = self.block_diag(t_m.t_5_me, t_m.t_5_mo)\n        h_6_m = self.block_diag(t_m.t_6_me, t_m.t_6_mo)\n        keys = [\"h_0_m\", \"h_2_m\", \"h_5_m\", \"h_6_m\", \"a\", \"lamb_m\"]\n        values = [h_0_m, h_2_m, h_5_m, h_6_m, self.params[\"a\"], self.params[\"lamb_m\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdNN2Me","title":"<code>TmdNN2Me</code>","text":"<p>               Bases: <code>AbstractLattice</code></p> <p>3 bands model for even metal orbitals with the second nearest-neighbor hopping</p> Source code in <code>tmdybinding/tmd_lattice.py</code> <pre><code>class TmdNN2Me(AbstractLattice):\n    \"\"\"3 bands model for even metal orbitals with the second nearest-neighbor hopping\"\"\"\n    def __init__(self, **kwargs):\n        orbital = LatticeOrbitals(\n            l_number={\"M\": [0, 2, -2]},\n            orbs={\"M\": [\"dz2\", \"dx2y2\", \"dxy\"]},\n            group={\"M\": [0, 1, 1]}\n        )\n        super().__init__(orbital=orbital, params=liu2[\"MoS2\"], lattice_name=\"3 bands 2NN model\",\n                         n_v=0, n_b=3)\n        [setattr(self, var, kwargs[var]) for var in [*kwargs]]\n\n    def _generate_matrices(self):\n        t_m = TmdMatrices(self.params)\n        h_0_m = t_m.e_me\n        h_2_m = t_m.t_2_me\n        keys = [\"h_0_m\", \"h_2_m\", \"a\", \"lamb_m\"]\n        values = [h_0_m, h_2_m, self.params[\"a\"], self.params[\"lamb_m\"]]\n        self.lattice_params.set_params(dict([(key, value) for key, value in zip(keys, values)]))\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices","title":"<code>TmdStrainMatrices</code>","text":"<p>               Bases: <code>TmdMatrices</code></p> <p>Construct the strained TMD hopping matrices</p> Source code in <code>tmdybinding/tmd_strain.py</code> <pre><code>class TmdStrainMatrices(TmdMatrices):\n    \"\"\"Construct the strained TMD hopping matrices\"\"\"\n\n    def __init__(self, params: StrainParametersList):\n        \"\"\"Initialize the strained TMD hopping matrices\n\n        Parameters:\n            params (StrainParametersList): The parameters for the strained TMD lattice.\"\"\"\n        super().__init__(params)\n        self.params: StrainParametersList = params\n\n    @staticmethod\n    def _e_xr_u(u_0, u_1) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the chalcogen orbitals under uniaxial strain\"\"\"\n        return np.array([[u_0, 0, 0], [0, -u_0, u_1], [0, u_1, 0]])\n\n    @staticmethod\n    def _e_me_u(u_0, u_1) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the even metal orbitals under uniaxial strain\"\"\"\n        return np.array([[0, u_0, 0], [u_0, -u_1, 0], [0, 0, u_1]])\n\n    @staticmethod\n    def _e_mo_u(u_0) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the odd metal orbitals under uniaxial strain\"\"\"\n        return np.array([[u_0, 0], [0, -u_0]])\n\n    @staticmethod\n    def _e_xr_s(u_0, u_1) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the chalcogen orbitals under shear strain\"\"\"\n        return np.array([[0, -u_0, -u_1], [-u_0, 0, 0], [-u_1, 0, 0]])\n\n    @staticmethod\n    def _e_me_s(u_0, u_1) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the even metal orbitals under shear strain\"\"\"\n        return np.array([[0, 0, -u_0], [0, 0, -u_1], [-u_0, -u_1, 0]])\n\n    @staticmethod\n    def _e_mo_s(u_0) -&gt; np.ndarray:\n        \"\"\"The onsite matrix for the odd metal orbitals under shear strain\"\"\"\n        return np.array([[0, -u_0], [-u_0, 0]])\n\n    @staticmethod\n    def _t_n_e_s(u_5, u_6, u_7, u_8) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the first-, third- and fourth-nearest neighbours from the even metal orbitals under shear strain\"\"\"\n        return np.array([[u_5, u_6, 0], [0, 0, u_7], [0, 0, u_8]])\n\n    @staticmethod\n    def _t_n_o_s(u_3, u_4, u_5) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the first-, third- and fourth-nearest neighbours from the odd metal orbitals under shear strain\"\"\"\n        return np.array([[0, u_3], [u_4, 0], [u_5, 0]])\n\n    @staticmethod\n    def _t_m_xr_s(u_1, u_2, u_4) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second- and sixth-nearest neighbours from the chalcogen orbitals under shear strain\"\"\"\n        return np.array([[0, u_1, u_2], [u_1, 0, u_4], [u_2, -u_4, 0]])\n\n    @staticmethod\n    def _t_m_me_s(u_1, u_2, u_4) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second-, fifth- and sixth-nearest neighbours from the even metal orbitals under shear strain\"\"\"\n        return np.array([[0, u_1, u_2], [-u_1, 0, u_4], [u_2, u_4, 0]])\n\n    @staticmethod\n    def _t_m_mo_s(u_1) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the second-, fifth- and sixth-nearest neighbours from the odd metal orbitals under shear strain\"\"\"\n        return np.array([[0, u_1], [u_1, 0]])\n\n    @staticmethod\n    def _t_5_me_s(u_2, u_4, u_7, u_8) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the fifth-nearest neighbours from the even metal orbitals under shear strain\"\"\"\n        return np.array([[0, 0, u_2], [0, 0, u_4], [u_7, u_8, 0]])\n\n    @staticmethod\n    def _t_5_mo_s(u_1, u_3) -&gt; np.ndarray:\n        \"\"\"The hopping matrix for the fifth-nearest neighbours from the odd metal orbitals under shear strain\"\"\"\n        return np.array([[0, u_1], [u_3, 0]])\n\n    @staticmethod\n    def _t_5_xr_s(u_1, u_4, u_7, u_8) -&gt; np.ndarray:\n        \"\"\"The hopping matrices for the fifth-nearest neighbours from the chalcogen orbitals under shear strain\"\"\"\n        return np.array([[0, u_1, u_4], [u_7, 0, 0], [u_8, 0, 0]])\n\n    @property\n    def e_xe_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            np.diag((\n                self.params[f\"eps_0_x_e_b_{order_idx}\"],\n                self.params[f\"eps_0_x_e_b_{order_idx}\"],\n                self.params[f\"eps_1_x_e_b_{order_idx}\"]\n            ))\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_xo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            np.diag((\n                self.params[f\"eps_0_x_o_b_{order_idx}\"],\n                self.params[f\"eps_0_x_o_b_{order_idx}\"],\n                self.params[f\"eps_1_x_o_b_{order_idx}\"]\n            ))\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even metal orbitals under biaxial strain\"\"\"\n        return [\n            np.diag((\n                self.params[f\"eps_0_m_e_b_{order_idx}\"],\n                self.params[f\"eps_1_m_e_b_{order_idx}\"],\n                self.params[f\"eps_1_m_e_b_{order_idx}\"]\n            ))\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            np.diag((\n                self.params[f\"eps_0_m_e_b_{order_idx}\"],\n                self.params[f\"eps_0_m_e_b_{order_idx}\"]\n            ))\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_xe_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even chalcogen orbitals under uniaxial strain\"\"\"\n        return [self._e_xr_u(\n            self.params[f\"eps_0_x_e_u_{order_idx}\"],\n            self.params[f\"eps_1_x_e_u_{order_idx}\"]\n        ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_xo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._e_xr_u(\n                self.params[f\"eps_0_x_o_u_{order_idx}\"],\n                self.params[f\"eps_1_x_o_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._e_me_u(\n                self.params[f\"eps_0_m_e_u_{order_idx}\"],\n                self.params[f\"eps_1_m_e_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._e_mo_u(\n                self.params[f\"eps_0_m_o_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_xe_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._e_xr_s(\n                self.params[f\"eps_0_x_e_u_{order_idx}\"],\n                self.params[f\"eps_1_x_e_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_xo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._e_xr_s(\n                self.params[f\"eps_0_x_o_u_{order_idx}\"],\n                self.params[f\"eps_1_x_o_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the even metal orbitals under shear strain\"\"\"\n        return [\n            self._e_me_s(\n                self.params[f\"eps_0_m_e_u_{order_idx}\"],\n                self.params[f\"eps_1_m_e_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def e_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The hopping matrix for the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._e_mo_s(\n                self.params[f\"eps_0_m_o_u_{order_idx}\"]\n            )\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_1_{i}_m_e_b_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_1_{i}_m_o_b_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_me(*[self.params[f\"u_2_{i}_m_e_b_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_mo(*[self.params[f\"u_2_{i}_m_o_b_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xe_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_2_{i}_x_e_b_{order_idx}\"] for i in range(6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_2_{i}_x_o_b_{order_idx}\"] for i in range(6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_3_{i}_m_e_b_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_3_{i}_m_o_b_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_4_{i}_m_e_b_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_4_{i}_m_o_b_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_5_me(*[self.params[f\"u_5_{i}_m_e_b_{order_idx}\"] for i in (\"0\", \"1\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_5_mo(*[self.params[f\"u_5_{i}_m_o_b_{order_idx}\"] for i in (\"0\", \"2\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xe_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_5_xr(*[self.params[f\"u_5_{i}_x_e_b_{order_idx}\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_5_xr(*[self.params[f\"u_5_{i}_x_o_b_{order_idx}\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_me_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_me(*[self.params[f\"u_6_{i}_m_e_b_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_mo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_mo(*[self.params[f\"u_6_{i}_m_o_b_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xe_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_6_{i}_x_e_b_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xo_b(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_6_{i}_x_o_b_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_1_{i}_m_e_u_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_1_{i}_m_o_u_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_me(*[self.params[f\"u_2_{i}_m_e_u_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_mo(*[self.params[f\"u_2_{i}_m_o_u_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xe_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_2_{i}_x_e_u_{order_idx}\"] for i in range(6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_2_{i}_x_o_u_{order_idx}\"] for i in range(6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_3_{i}_m_e_u_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_3_{i}_m_o_u_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_e(*[self.params[f\"u_4_{i}_m_e_u_{order_idx}\"] for i in range(5)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_n_o(*[self.params[f\"u_4_{i}_m_o_u_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_5_me(*[self.params[f\"u_5_{i}_m_e_u_{order_idx}\"] for i in (\"0\", \"1\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_5_mo(*[self.params[f\"u_5_{i}_m_o_u_{order_idx}\"] for i in (\"0\", \"2\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xe_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_5_xr(*[self.params[f\"u_5_{i}_x_e_u_{order_idx}\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_5_xr(*[self.params[f\"u_5_{i}_x_o_u_{order_idx}\"] for i in (\"0\", \"2\", \"3\", \"5\", \"6\")])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_me_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_me(*[self.params[f\"u_6_{i}_m_e_u_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_mo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_mo(*[self.params[f\"u_6_{i}_m_o_u_{order_idx}\"] for i in range(3)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xe_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_6_{i}_x_e_u_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xo_u(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain\"\"\"\n        return [\n            self._t_m_xr(*[self.params[f\"u_6_{i}_x_o_u_{order_idx}\"] for i in range(6)])\n            for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_e_s(*[self.params[f\"u_1_{i}_m_e_s_{order_idx}\"] for i in range(5, 9)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_1_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The first-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_o_s(*[self.params[f\"u_1_{i}_m_o_s_{order_idx}\"] for i in range(3, 6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_m_me_s(*[self.params[f\"u_2_{i}_m_e_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_m_mo_s(*[self.params[f\"u_2_{i}_m_o_s_{order_idx}\"] for i in [1]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xe_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_m_xr_s(*[self.params[f\"u_2_{i}_x_e_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_2_xo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_m_xr_s(*[self.params[f\"u_2_{i}_x_o_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_e_s(*[self.params[f\"u_3_{i}_m_e_s_{order_idx}\"] for i in range(5, 9)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_3_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The third-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_o_s(*[self.params[f\"u_3_{i}_m_o_s_{order_idx}\"] for i in range(3, 6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_e_s(*[self.params[f\"u_4_{i}_m_e_s_{order_idx}\"] for i in range(5, 9)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_4_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fourth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_n_o_s(*[self.params[f\"u_4_{i}_m_o_s_{order_idx}\"] for i in range(3, 6)]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_5_me_s(*[self.params[f\"u_5_{i}_m_e_s_{order_idx}\"] for i in [2, 4, 7, 8]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_5_mo_s(*[self.params[f\"u_5_{i}_m_o_s_{order_idx}\"] for i in [1, 3]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xe_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_5_xr_s(*[self.params[f\"u_5_{i}_x_e_s_{order_idx}\"] for i in [1, 4, 7, 8]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_5_xo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_5_xr_s(*[self.params[f\"u_5_{i}_x_o_s_{order_idx}\"] for i in [1, 4, 7, 8]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_me_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even metal orbitals under shear strain\"\"\"\n        return [\n            self._t_m_me_s(*[self.params[f\"u_6_{i}_m_e_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_mo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain\"\"\"\n        return [\n            self._t_m_mo_s(*[self.params[f\"u_6_{i}_m_o_s_{order_idx}\"] for i in [1]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xe_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_m_xr_s(*[self.params[f\"u_6_{i}_x_e_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n\n    @property\n    def t_6_xo_s(self) -&gt; list[np.ndarray]:\n        \"\"\"The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain\"\"\"\n        return [\n            self._t_m_xr_s(*[self.params[f\"u_6_{i}_x_o_s_{order_idx}\"] for i in [1, 2, 4]]\n            ) for order_idx in range(1, self.params.max_order+1)]\n</code></pre>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_me_b","title":"<code>e_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_me_s","title":"<code>e_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_me_u","title":"<code>e_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_mo_b","title":"<code>e_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_mo_s","title":"<code>e_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_mo_u","title":"<code>e_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xe_b","title":"<code>e_xe_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xe_s","title":"<code>e_xe_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xe_u","title":"<code>e_xe_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the even chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xo_b","title":"<code>e_xo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xo_s","title":"<code>e_xo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.e_xo_u","title":"<code>e_xo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The hopping matrix for the odd chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_me_b","title":"<code>t_1_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_me_s","title":"<code>t_1_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_me_u","title":"<code>t_1_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_mo_b","title":"<code>t_1_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_mo_s","title":"<code>t_1_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_1_mo_u","title":"<code>t_1_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The first-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_me_b","title":"<code>t_2_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_me_s","title":"<code>t_2_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_me_u","title":"<code>t_2_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_mo_b","title":"<code>t_2_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_mo_s","title":"<code>t_2_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_mo_u","title":"<code>t_2_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xe_b","title":"<code>t_2_xe_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xe_s","title":"<code>t_2_xe_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xe_u","title":"<code>t_2_xe_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xo_b","title":"<code>t_2_xo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xo_s","title":"<code>t_2_xo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_2_xo_u","title":"<code>t_2_xo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The second-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_me_b","title":"<code>t_3_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_me_s","title":"<code>t_3_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_me_u","title":"<code>t_3_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_mo_b","title":"<code>t_3_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_mo_s","title":"<code>t_3_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_3_mo_u","title":"<code>t_3_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The third-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_me_b","title":"<code>t_4_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_me_s","title":"<code>t_4_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_me_u","title":"<code>t_4_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_mo_b","title":"<code>t_4_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_mo_s","title":"<code>t_4_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_4_mo_u","title":"<code>t_4_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fourth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_me_b","title":"<code>t_5_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_me_s","title":"<code>t_5_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_me_u","title":"<code>t_5_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_mo_b","title":"<code>t_5_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_mo_s","title":"<code>t_5_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_mo_u","title":"<code>t_5_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xe_b","title":"<code>t_5_xe_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xe_s","title":"<code>t_5_xe_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xe_u","title":"<code>t_5_xe_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xo_b","title":"<code>t_5_xo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xo_s","title":"<code>t_5_xo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_5_xo_u","title":"<code>t_5_xo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The fifth-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_me_b","title":"<code>t_6_me_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_me_s","title":"<code>t_6_me_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_me_u","title":"<code>t_6_me_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_mo_b","title":"<code>t_6_mo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd metal orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_mo_s","title":"<code>t_6_mo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd metal orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_mo_u","title":"<code>t_6_mo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd metal orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xe_b","title":"<code>t_6_xe_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xe_s","title":"<code>t_6_xe_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xe_u","title":"<code>t_6_xe_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the even chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xo_b","title":"<code>t_6_xo_b: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under biaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xo_s","title":"<code>t_6_xo_s: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under shear strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.t_6_xo_u","title":"<code>t_6_xo_u: list[np.ndarray]</code>  <code>property</code>","text":"<p>The sixth-nearest neighbour hopping matrix from the odd chalcogen orbitals under uniaxial strain</p>"},{"location":"documentation/api/#tmdybinding.TmdStrainMatrices.__init__","title":"<code>__init__(params)</code>","text":"<p>Initialize the strained TMD hopping matrices</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>StrainParametersList</code> <p>The parameters for the strained TMD lattice.</p> required Source code in <code>tmdybinding/tmd_strain.py</code> <pre><code>def __init__(self, params: StrainParametersList):\n    \"\"\"Initialize the strained TMD hopping matrices\n\n    Parameters:\n        params (StrainParametersList): The parameters for the strained TMD lattice.\"\"\"\n    super().__init__(params)\n    self.params: StrainParametersList = params\n</code></pre>"},{"location":"documentation/api/#tmdybinding.VariableStorage","title":"<code>VariableStorage</code>","text":"<p>Class for saving the matrices and variables in the AbstractLattice-class. There are also checks for a consistent model, where the sizes of the matrices, the included hoppings and the onsite matrices are checked.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>class VariableStorage:\n    \"\"\"\n    Class for saving the matrices and variables in the AbstractLattice-class.\n    There are also checks for a consistent model, where the sizes of the matrices, the included hoppings and the onsite\n    matrices are checked.\n    \"\"\"\n\n    def __init__(self, params_dict: Optional[dict] = None):\n        \"\"\"Make a VariableStorage object with the given parameters. If no parameters are given, the parameters are None.\n\n        Parameters:\n            params_dict (Optional[dict]): The parameters for the lattice model.\n                The dictionary entries must be in the format `\"name\": parameter`.\n                The possible parameters are `\"h_0_m\"`, `\"h_0_c\"`, `\"h_1_m\"`, `\"h_2_m\"`, `\"h_2_c\"`, `\"h_3_m\"`, `\"h_4_m\"`,\n                `\"h_5_m\"`, `\"h_5_c\"`, `\"h_6_m\"`, `\"h_6_c\"`, `\"a\"`, `\"lamb_m\"` and `\"lamb_c\"`.\n        \"\"\"\n        self.__h_0_m = None\n        self.__h_0_c = None\n        self.__h_1_m = None\n        self.__h_2_m = None\n        self.__h_2_c = None\n        self.__h_3_m = None\n        self.__h_4_m = None\n        self.__h_5_m = None\n        self.__h_5_c = None\n        self.__h_6_m = None\n        self.__h_6_c = None\n        self.__a = None\n        self.__lamb_m = None\n        self.__lamb_c = None\n        self.__keys = [\n            \"h_0_m\", \"h_0_c\",\n            \"h_1_m\",\n            \"h_2_m\", \"h_2_c\",\n            \"h_3_m\",\n            \"h_4_m\",\n            \"h_5_m\", \"h_5_c\",\n            \"h_6_m\", \"h_6_c\",\n            \"a\", \"lamb_m\", \"lamb_c\"\n        ]\n        if params_dict is not None:\n            self.set_params(params_dict)\n\n    @staticmethod\n    def _params_check(params_dict: dict, param_name: str) -&gt; Optional[np.ndarray]:\n        if param_name in params_dict.keys():\n            if params_dict[param_name] is not None:\n                return np.array(params_dict[param_name])\n        return None\n\n    def set_params(self, params_dict: dict, keep: bool = True):\n        \"\"\"Set the parameters for the lattice model.\n\n        Parameters:\n            params_dict (dict): The parameters for the lattice model.\n                The dictionary entries must be in the format `\"name\": parameter`.\n                The possible parameters are `\"h_0_m\"`, `\"h_0_c\"`, `\"h_1_m\"`, `\"h_2_m\"`, `\"h_2_c\"`, `\"h_3_m\"`, `\"h_4_m\"`,\n                `\"h_5_m\"`, `\"h_5_c\"`, `\"h_6_m\"`, `\"h_6_c\"`, `\"a\"`, `\"lamb_m\"` and `\"lamb_c\"`.\n            keep (bool): If True, the parameters that are not included in the `param_dict`are kept as they are.\n                If False, the parameters that are not given are set to None.\n        \"\"\"\n        params = self.to_dict() if keep else {}\n        for name in params_dict.keys():\n            assert str(name) in self.__keys, f\"key {name} not in expected hoppings, possible wrong name\"\n            params[name] = params_dict[name]\n        self._component_check(params)\n        self._shape_check(params)\n        self.__h_0_m = self._params_check(params, \"h_0_m\")\n        self.__h_0_c = self._params_check(params, \"h_0_c\")\n        self.__h_1_m = self._params_check(params, \"h_1_m\")\n        self.__h_2_m = self._params_check(params, \"h_2_m\")\n        self.__h_2_c = self._params_check(params, \"h_2_c\")\n        self.__h_3_m = self._params_check(params, \"h_3_m\")\n        self.__h_4_m = self._params_check(params, \"h_4_m\")\n        self.__h_5_m = self._params_check(params, \"h_5_m\")\n        self.__h_5_c = self._params_check(params, \"h_5_c\")\n        self.__h_6_m = self._params_check(params, \"h_6_m\")\n        self.__h_6_c = self._params_check(params, \"h_6_c\")\n        self.__a = self._params_check(params, \"a\")\n        self.__lamb_m = self._params_check(params, \"lamb_m\")\n        self.__lamb_c = self._params_check(params, \"lamb_c\")\n\n    def _make_bools(self, params_dict: dict):\n        return [self._attr_check(name, params_dict) for name in self.__keys]\n\n    def _component_check(self, params_dict: dict):\n        (m_bool, c_bool,\n         h_1_m_bool,\n         h_2_m_bool, h_2_c_bool,\n         h_3_m_bool,\n         h_4_m_bool,\n         h_5_m_bool, h_5_c_bool,\n         h_6_m_bool, h_6_c_bool) = self._make_bools(params_dict)[:-3]\n        assert m_bool or c_bool, \"not X nor M in model\"\n        assert not (not m_bool and h_1_m_bool), \"not M in model and 1st hopping from M\"\n        assert not (not c_bool and h_1_m_bool), \"not M in model and 1st hopping to X\"\n        assert not (not m_bool and h_2_m_bool), \"not M in model and 2nd hopping from/to M\"\n        assert not (not c_bool and h_2_c_bool), \"not M in model and 2nd hopping from/to X\"\n        assert not (not m_bool and h_3_m_bool), \"not M in model and 3rd hopping from M\"\n        assert not (not c_bool and h_3_m_bool), \"not M in model and 3rd hopping to X\"\n        assert not (not m_bool and h_4_m_bool), \"not M in model and 4rd hopping from M\"\n        assert not (not c_bool and h_4_m_bool), \"not M in model and 4rd hopping to X\"\n        assert not (not m_bool and h_5_m_bool), \"not M in model and 5th hopping from/to M\"\n        assert not (not c_bool and h_5_c_bool), \"not M in model and 5th hopping from/to X\"\n        assert not (not m_bool and h_6_m_bool), \"not M in model and 6th hopping from/to M\"\n        assert not (not c_bool and h_6_c_bool), \"not M in model and 6th hopping from/to X\"\n        assert h_1_m_bool or h_2_c_bool or h_2_m_bool or h_3_m_bool or h_4_m_bool or h_5_c_bool or h_5_m_bool or \\\n               h_6_c_bool or h_6_m_bool, \"no hoppings specified in the model\"\n\n    def _shape_check(self, params_dict: dict):\n        (m_bool, c_bool,\n         h_1_m_bool,\n         h_2_m_bool, h_2_c_bool,\n         h_3_m_bool,\n         h_4_m_bool,\n         h_5_m_bool, h_5_c_bool,\n         h_6_m_bool, h_6_c_bool) = self._make_bools(params_dict)[:-3]\n        if m_bool:\n            m_shape = self._check_shape(params_dict[\"h_0_m\"])\n            if h_1_m_bool:\n                assert np.shape(params_dict[\"h_1_m\"])[1] == m_shape, \"shape 1st hopping from M not correct\"\n            if h_2_m_bool:\n                assert np.shape(params_dict[\"h_2_m\"])[0] == m_shape, \"shape 2nd hopping to M not correct\"\n                assert np.shape(params_dict[\"h_2_m\"])[1] == m_shape, \"shape 2nd hopping from M not correct\"\n            if h_3_m_bool:\n                assert np.shape(params_dict[\"h_3_m\"])[1] == m_shape, \"shape 3rd hopping from M not correct\"\n            if h_4_m_bool:\n                assert np.shape(params_dict[\"h_4_m\"])[1] == m_shape, \"shape 4rd hopping from M not correct\"\n            if h_5_m_bool:\n                assert np.shape(params_dict[\"h_5_m\"])[0] == m_shape, \"shape 5th hopping to M not correct\"\n                assert np.shape(params_dict[\"h_5_m\"])[1] == m_shape, \"shape 5th hopping from M not correct\"\n            if h_6_m_bool:\n                assert np.shape(params_dict[\"h_6_m\"])[0] == m_shape, \"shape 6th hopping to M not correct\"\n                assert np.shape(params_dict[\"h_6_m\"])[1] == m_shape, \"shape 6th hopping from M not correct\"\n        if c_bool:\n            c_shape = self._check_shape(params_dict[\"h_0_c\"])\n            if h_1_m_bool:\n                assert np.shape(params_dict[\"h_1_m\"])[0] == c_shape, \"shape 1st hopping to X not correct\"\n            if h_2_c_bool:\n                assert np.shape(params_dict[\"h_2_c\"])[0] == c_shape, \"shape 2nd hopping to X not correct\"\n                assert np.shape(params_dict[\"h_2_c\"])[1] == c_shape\n            if h_3_m_bool:\n                assert np.shape(params_dict[\"h_3_m\"])[0] == c_shape, \"shape 3rd hopping to X not correct\"\n            if h_4_m_bool:\n                assert np.shape(params_dict[\"h_4_m\"])[0] == c_shape, \"shape 4rd hopping to X not correct\"\n            if h_5_c_bool:\n                assert np.shape(params_dict[\"h_5_c\"])[0] == c_shape, \"shape 5th hopping to X not correct\"\n                assert np.shape(params_dict[\"h_5_c\"])[1] == c_shape, \"shape 5th hopping from X not correct\"\n            if h_6_c_bool:\n                assert np.shape(params_dict[\"h_6_c\"])[0] == c_shape, \"shape 6th hopping to X not correct\"\n                assert np.shape(params_dict[\"h_6_c\"])[1] == c_shape, \"shape 6th hopping from X not correct\"\n\n    @staticmethod\n    def _attr_check(name, params_dict: dict):\n        if name in params_dict.keys():\n            return params_dict[name] is not None\n        else:\n            return False\n\n    @staticmethod\n    def _check_shape(h_0):\n        h_0_shape = np.shape(h_0)\n        assert len(h_0_shape) &lt; 3, \"onsite energy too many dims (max 2 as matrix)\"\n        if len(h_0_shape) == 2:\n            assert h_0_shape[0] == h_0_shape[1] or h_0_shape[0] == 1, \"shape of x and y not the same for onsite energy\"\n            return h_0_shape[1]\n        else:\n            return h_0_shape[0]\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Return the parameters as a dictionary in the format `\"name\": parameter`.\"\"\"\n        dict_list = []\n        for name in self.__keys:\n            value = getattr(self, name)\n            if value is not None:\n                dict_list.append((name, value))\n        return dict(dict_list)\n\n    @property\n    def h_0_m(self) -&gt; np.ndarray:\n        \"\"\"The onsite energy for the metal atom.\"\"\"\n        return self.__h_0_m\n\n    @h_0_m.setter\n    def h_0_m(self, value: np.ndarray):\n        self.set_params({\"h_0_m\": value})\n\n    @property\n    def h_0_c(self) -&gt; np.ndarray:\n        \"\"\"The onsite energy for the chalcogen atom.\"\"\"\n        return self.__h_0_c\n\n    @h_0_c.setter\n    def h_0_c(self, value: np.ndarray):\n        self.set_params({\"h_0_c\": value})\n\n    @property\n    def h_1_m(self) -&gt; np.ndarray:\n        \"\"\"The first nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_1_m\n\n    @h_1_m.setter\n    def h_1_m(self, value: np.ndarray):\n        self.set_params({\"h_1_m\": value})\n\n    @property\n    def h_2_m(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_2_m\n\n    @h_2_m.setter\n    def h_2_m(self, value: np.ndarray):\n        self.set_params({\"h_2_m\": value})\n\n    @property\n    def h_2_c(self) -&gt; np.ndarray:\n        \"\"\"The second-nearest neighbour hopping from the chalcogen atom.\"\"\"\n        return self.__h_2_c\n\n    @h_2_c.setter\n    def h_2_c(self, value: np.ndarray):\n        self.set_params({\"h_2_c\": value})\n\n    @property\n    def h_3_m(self) -&gt; np.ndarray:\n        \"\"\"The third-nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_3_m\n\n    @h_3_m.setter\n    def h_3_m(self, value: np.ndarray):\n        self.set_params({\"h_3_m\": value})\n\n    @property\n    def h_4_m(self) -&gt; np.ndarray:\n        \"\"\"The fourth-nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_4_m\n\n    @h_4_m.setter\n    def h_4_m(self, value: np.ndarray):\n        self.set_params({\"h_4_m\": value})\n\n    @property\n    def h_5_m(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_5_m\n\n    @h_5_m.setter\n    def h_5_m(self, value: np.ndarray):\n        self.set_params({\"h_5_m\": value})\n\n    @property\n    def h_5_c(self) -&gt; np.ndarray:\n        \"\"\"The fifth-nearest neighbour hopping from the chalcogen atom.\"\"\"\n        return self.__h_5_c\n\n    @h_5_c.setter\n    def h_5_c(self, value: np.ndarray):\n        self.set_params({\"h_5_c\": value})\n\n    @property\n    def h_6_m(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping from the metal atom.\"\"\"\n        return self.__h_6_m\n\n    @h_6_m.setter\n    def h_6_m(self, value: np.ndarray):\n        self.set_params({\"h_6_m\": value})\n\n    @property\n    def h_6_c(self) -&gt; np.ndarray:\n        \"\"\"The sixth-nearest neighbour hopping from the chalcogen atom.\"\"\"\n        return self.__h_6_c\n\n    @h_6_c.setter\n    def h_6_c(self, value: np.ndarray):\n        self.set_params({\"h_6_c\": value})\n\n    @property\n    def a(self) -&gt; float:\n        \"\"\"The lattice constant.\"\"\"\n        return self.__a\n\n    @a.setter\n    def a(self, value: float):\n        self.set_params({\"a\": value})\n\n    @property\n    def lamb_m(self) -&gt; float:\n        \"\"\"The spin-orbit coupling for the metal atom.\"\"\"\n        return self.__lamb_m\n\n    @lamb_m.setter\n    def lamb_m(self, value: float):\n        self.set_params({\"lamb_m\": value})\n\n    @property\n    def lamb_c(self) -&gt; float:\n        \"\"\"The spin-orbit coupling for the chalcogen atom.\"\"\"\n        return self.__lamb_c\n\n    @lamb_c.setter\n    def lamb_c(self, value: float):\n        self.set_params({\"lamb_c\": value})\n</code></pre>"},{"location":"documentation/api/#tmdybinding.VariableStorage.a","title":"<code>a: float</code>  <code>property</code> <code>writable</code>","text":"<p>The lattice constant.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_0_c","title":"<code>h_0_c: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The onsite energy for the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_0_m","title":"<code>h_0_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The onsite energy for the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_1_m","title":"<code>h_1_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The first nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_2_c","title":"<code>h_2_c: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The second-nearest neighbour hopping from the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_2_m","title":"<code>h_2_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The second-nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_3_m","title":"<code>h_3_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The third-nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_4_m","title":"<code>h_4_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The fourth-nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_5_c","title":"<code>h_5_c: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The fifth-nearest neighbour hopping from the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_5_m","title":"<code>h_5_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The fifth-nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_6_c","title":"<code>h_6_c: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The sixth-nearest neighbour hopping from the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.h_6_m","title":"<code>h_6_m: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>The sixth-nearest neighbour hopping from the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.lamb_c","title":"<code>lamb_c: float</code>  <code>property</code> <code>writable</code>","text":"<p>The spin-orbit coupling for the chalcogen atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.lamb_m","title":"<code>lamb_m: float</code>  <code>property</code> <code>writable</code>","text":"<p>The spin-orbit coupling for the metal atom.</p>"},{"location":"documentation/api/#tmdybinding.VariableStorage.__init__","title":"<code>__init__(params_dict=None)</code>","text":"<p>Make a VariableStorage object with the given parameters. If no parameters are given, the parameters are None.</p> <p>Parameters:</p> Name Type Description Default <code>params_dict</code> <code>Optional[dict]</code> <p>The parameters for the lattice model. The dictionary entries must be in the format <code>\"name\": parameter</code>. The possible parameters are <code>\"h_0_m\"</code>, <code>\"h_0_c\"</code>, <code>\"h_1_m\"</code>, <code>\"h_2_m\"</code>, <code>\"h_2_c\"</code>, <code>\"h_3_m\"</code>, <code>\"h_4_m\"</code>, <code>\"h_5_m\"</code>, <code>\"h_5_c\"</code>, <code>\"h_6_m\"</code>, <code>\"h_6_c\"</code>, <code>\"a\"</code>, <code>\"lamb_m\"</code> and <code>\"lamb_c\"</code>.</p> <code>None</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def __init__(self, params_dict: Optional[dict] = None):\n    \"\"\"Make a VariableStorage object with the given parameters. If no parameters are given, the parameters are None.\n\n    Parameters:\n        params_dict (Optional[dict]): The parameters for the lattice model.\n            The dictionary entries must be in the format `\"name\": parameter`.\n            The possible parameters are `\"h_0_m\"`, `\"h_0_c\"`, `\"h_1_m\"`, `\"h_2_m\"`, `\"h_2_c\"`, `\"h_3_m\"`, `\"h_4_m\"`,\n            `\"h_5_m\"`, `\"h_5_c\"`, `\"h_6_m\"`, `\"h_6_c\"`, `\"a\"`, `\"lamb_m\"` and `\"lamb_c\"`.\n    \"\"\"\n    self.__h_0_m = None\n    self.__h_0_c = None\n    self.__h_1_m = None\n    self.__h_2_m = None\n    self.__h_2_c = None\n    self.__h_3_m = None\n    self.__h_4_m = None\n    self.__h_5_m = None\n    self.__h_5_c = None\n    self.__h_6_m = None\n    self.__h_6_c = None\n    self.__a = None\n    self.__lamb_m = None\n    self.__lamb_c = None\n    self.__keys = [\n        \"h_0_m\", \"h_0_c\",\n        \"h_1_m\",\n        \"h_2_m\", \"h_2_c\",\n        \"h_3_m\",\n        \"h_4_m\",\n        \"h_5_m\", \"h_5_c\",\n        \"h_6_m\", \"h_6_c\",\n        \"a\", \"lamb_m\", \"lamb_c\"\n    ]\n    if params_dict is not None:\n        self.set_params(params_dict)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.VariableStorage.set_params","title":"<code>set_params(params_dict, keep=True)</code>","text":"<p>Set the parameters for the lattice model.</p> <p>Parameters:</p> Name Type Description Default <code>params_dict</code> <code>dict</code> <p>The parameters for the lattice model. The dictionary entries must be in the format <code>\"name\": parameter</code>. The possible parameters are <code>\"h_0_m\"</code>, <code>\"h_0_c\"</code>, <code>\"h_1_m\"</code>, <code>\"h_2_m\"</code>, <code>\"h_2_c\"</code>, <code>\"h_3_m\"</code>, <code>\"h_4_m\"</code>, <code>\"h_5_m\"</code>, <code>\"h_5_c\"</code>, <code>\"h_6_m\"</code>, <code>\"h_6_c\"</code>, <code>\"a\"</code>, <code>\"lamb_m\"</code> and <code>\"lamb_c\"</code>.</p> required <code>keep</code> <code>bool</code> <p>If True, the parameters that are not included in the <code>param_dict</code>are kept as they are. If False, the parameters that are not given are set to None.</p> <code>True</code> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def set_params(self, params_dict: dict, keep: bool = True):\n    \"\"\"Set the parameters for the lattice model.\n\n    Parameters:\n        params_dict (dict): The parameters for the lattice model.\n            The dictionary entries must be in the format `\"name\": parameter`.\n            The possible parameters are `\"h_0_m\"`, `\"h_0_c\"`, `\"h_1_m\"`, `\"h_2_m\"`, `\"h_2_c\"`, `\"h_3_m\"`, `\"h_4_m\"`,\n            `\"h_5_m\"`, `\"h_5_c\"`, `\"h_6_m\"`, `\"h_6_c\"`, `\"a\"`, `\"lamb_m\"` and `\"lamb_c\"`.\n        keep (bool): If True, the parameters that are not included in the `param_dict`are kept as they are.\n            If False, the parameters that are not given are set to None.\n    \"\"\"\n    params = self.to_dict() if keep else {}\n    for name in params_dict.keys():\n        assert str(name) in self.__keys, f\"key {name} not in expected hoppings, possible wrong name\"\n        params[name] = params_dict[name]\n    self._component_check(params)\n    self._shape_check(params)\n    self.__h_0_m = self._params_check(params, \"h_0_m\")\n    self.__h_0_c = self._params_check(params, \"h_0_c\")\n    self.__h_1_m = self._params_check(params, \"h_1_m\")\n    self.__h_2_m = self._params_check(params, \"h_2_m\")\n    self.__h_2_c = self._params_check(params, \"h_2_c\")\n    self.__h_3_m = self._params_check(params, \"h_3_m\")\n    self.__h_4_m = self._params_check(params, \"h_4_m\")\n    self.__h_5_m = self._params_check(params, \"h_5_m\")\n    self.__h_5_c = self._params_check(params, \"h_5_c\")\n    self.__h_6_m = self._params_check(params, \"h_6_m\")\n    self.__h_6_c = self._params_check(params, \"h_6_c\")\n    self.__a = self._params_check(params, \"a\")\n    self.__lamb_m = self._params_check(params, \"lamb_m\")\n    self.__lamb_c = self._params_check(params, \"lamb_c\")\n</code></pre>"},{"location":"documentation/api/#tmdybinding.VariableStorage.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the parameters as a dictionary in the format <code>\"name\": parameter</code>.</p> Source code in <code>tmdybinding/tmd_abstract_lattice.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Return the parameters as a dictionary in the format `\"name\": parameter`.\"\"\"\n    dict_list = []\n    for name in self.__keys:\n        value = getattr(self, name)\n        if value is not None:\n            dict_list.append((name, value))\n    return dict(dict_list)\n</code></pre>"},{"location":"documentation/api/#tmdybinding.tests","title":"<code>tests()</code>","text":"<p>Run the package tests.</p> Source code in <code>tmdybinding/__init__.py</code> <pre><code>def tests():\n    \"\"\"Run the package tests.\"\"\"\n    import pytest\n    import pathlib\n    import os\n    from pybinding.utils.misc import cd\n    import pybinding as pb\n\n    module_path = pathlib.Path(__file__).parent\n\n    args = []\n    if (module_path / 'tests').exists():\n        # tests are inside installed package -&gt; use read-only mode\n        args.append('--failpath=' + os.getcwd() + '/failed')\n        with cd(module_path):\n            args += ['-c', str(module_path / 'tests/local.cfg'), str(module_path)]\n            error_code = pytest.main(args)\n    else:\n        # tests are in dev environment -&gt; use development mode\n        with cd(module_path.parent):\n            error_code = pytest.main(args)\n\n    return error_code or None\n</code></pre>"},{"location":"documentation/parameters/","title":"Possible parameters","text":""},{"location":"documentation/parameters/#possible-parameters","title":"Possible parameters","text":"<p>In the subpackage <code>tmdybinding.parameters</code> you can find the parameters for the Symmetry Group (SG) and Slater-Koster (SK) models, respectively. These parameters are dictionaries with the index the name of the different TMDs considered and have as item the parameters in the form of a ParametersList object.</p> <p>Here is an overview of the possible choices for the parameters and the best associated class to use for the parameter from literature:</p> Name Type Materials Class Ref <code>tmdy.liu2</code> SG <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"MoTe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code>, <code>\"WTe2\"</code> TmdNN2Me G-B. Liu, 2013 <code>tmdy.liu6</code> SG <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"MoTe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code>, <code>\"WTe2\"</code> TmdNN256Me G-B. Liu, 2013 <code>tmdy.wu</code> SG <code>\"MoS2\"</code> TmdNN256Meo F. Wu, 2015 <code>tmdy.fang</code> SG <code>\"MoS2\"</code> TmdNN123MeoXeo S. Fang, 2015 <code>tmdy.jorissen</code> SG <code>\"MoS2\"</code> TmdNN12MeXe B. Jorissen, 2024 <code>tmdy.all</code> SG <code>\"MoS2\"</code> TmdNN123456MeoXeo B. Jorissen, 2024 <code>tmdy.rostami</code> SK <code>\"MoS2\"</code> TmdNN12MeXe H. Rostami, 2015 <code>tmdy.dias</code> SK <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"MoTe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code> TmdNN125MeoXeo A. Dias, 2018 <code>tmdy.cappelluti</code> SK <code>\"MoS2\"</code> TmdNN12MeoXeo E. Cappelluti, 2013 <code>tmdy.roldan</code> SK <code>\"MoS2\"</code> TmdNN12MeoXeo R. Roldan, 2014 <code>tmdy.ridolfi</code> SK <code>\"MoS2\": {\"normal\", \"vb\", \"minimal\"}</code> TmdNN12MeoXeo E. Ridolfi, 2015 <code>tmdy.venkateswarlu</code> SK <code>\"MoS2\"</code> TmdNN12MeoXeo S. Venkateswarlu, 2020 <code>tmdy.silva_guillen</code> SK <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code> TmdNN12MeoXeo J. Silva-Guillen, 2016 <code>tmdy.pearce</code> SK <code>\"MoS2\"</code> TmdNN12MeoXeo A. Pearce, 2016 <code>tmdy.bieniek</code> SK <code>\"MoS2\"</code> TmdNN12MeoXeo M. Bieniek, 2018 <code>tmdy.abdi</code> SK <code>\"MoS2\"</code>,  <code>\"MoSe2\"</code>, <code>\"WS2\"</code> TmdNN12MeoXeo M. Abdi, 2020 <code>tmdy.peng6</code> SK <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code> TmdNN12MeXe Z. Peng, 2024 <code>tmdy.peng11</code> SK <code>\"MoS2\"</code>, <code>\"MoSe2\"</code>, <code>\"WS2\"</code>, <code>\"WSe2\"</code> TmdNN125MeoXeo Z. Peng, 2024 <p>Selecting other classes</p> <p>The fourth column from the table above is the suggested model to be used with the parameters. However, you can use any of the classes to build the matrices associated to the hoppings of that model. The only difference is that some parameters that are not orginally defined for that model will be set to zero, giving unexpected results.</p> <p>Starting from Slater-Koster parameters</p> <p>The TMDybinding package automatically converts the Slater-Koster parameters to the Symmetry Group parameters. If you save your variables in the <code>SKParametersList</code> object, you can obtain the Symmetry Group parameters by calling the appropriate parameter to this class.</p> <p>You also have the option to specify the angle between the plane of the Metal atoms and the first nearest neighbour hopping direction to the Chalcogenide atoms.</p>"}]}